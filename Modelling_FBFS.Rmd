---
title: "Modelling Risk and Uncertainty in Flood-based farming systems."
author:
- Issoufou Liman:
    correspondence: yes
    email: issoufoul@gmail.com
    institute:
    - ICRAF
    - KU
- institute:
  - ICRAF
  - ZEF
  name: Cory Whitney
- institute: KU
  name: James Kungu
- institute:
  - ICRAF
  - ZEF
  - INRES
  name: Eike Luedeling
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  bookdown::pdf_document2:
    fig_caption: yes
    includes:
      in_header: ./formating_files/inheader_2.tex
    keep_tex: yes
    latex_engine: xelatex
    number_sections: yes
    pandoc_args:
    - --lua-filter=./formating_files/scholarly-metadata.lua
    - --lua-filter=./formating_files/author-info-blocks.lua
    toc: true
    toc_depth: 5
  bookdown::html_document2:
    df_print: paged
    fig_caption: yes
    keep_tex: yes
    latex_engine: xelatex
    number_sections: yes
    pandoc_args:
    - --lua-filter=./formating_files/scholarly-metadata.lua
    - --lua-filter=./formating_files/author-info-blocks.lua
    toc: true
    toc_depth: 5
    toc_float:
      collapsed: yes
      smooth_scroll: yes
  bookdown::word_document2:
    fig_caption: yes
    pandoc_args:
    - --lua-filter=./formating_files/scholarly-metadata.lua
    - --lua-filter=./formating_files/author-info-blocks.lua
    toc: true
    toc_depth: 5
citecolor: red
classoption: oneside
csl: ./referencing_files/scientific-reports.csl
abstract: Modelling the performance of crops grown under specific conditions is an
  important tool for decision support. Towards this end, many crop models are being
  used to inform agricultural policies. However, many of these models are applied
  beyond a reasonable scope of application, mainly because they are either designed
  for other settings, they fail to capture system complexity, or because some of their
  data requirements are not within reach. In this paper, we demonstrate an approach
  to overcome the above-mentioned problems using a probabilistic crop model based
  on the Decision Theory methods. Using the innovative method, we transparently use
  all available sources of information and consider various sources of uncertainty
  using participatory analysis. The transdisciplinary process provides a model where
  all important variables and their interactions, as determined by local experts and
  relevant literature, are used to simulate the plausible ranges of expected grain
  and biomass yield at various stages of crop development. System components are described
  using individual Bayesian networks in which expert knowledge is employed to specify
  causality among important variables along with their probability distributions.
  These Bayesian networks, along with other quantitative variables, are used as input
  for a Monte Carlo model to simulate the plausible performance of crops. Our objective
  is to develop a customizable solution-oriented approach for crop modelling in settings
  where data and resources are limited. We describe how such a model can be developed
  and provide three case study applications focusing on flood-based farming systems.
  The case studies illustrate the extensible scope of such a model by assessing the
  performance of a cropping system, individual crops, or other factors of high agricultural
  importance across the Tigray region of Ethiopia and Kisumu County of Kenya. The
  probabilistic tools and transdisciplinary approaches of Decision Theory allow experts
  and analysts to address the system complexity and data uncertainties in crop modelling.
documentclass: article
fontfamily: mathpazo
fontsize: 12pt
geometry: margin=1in
institute:
- ICRAF: World Agroforestry Centre (ICRAF), United Nations Avenue, Gigiri, P. O. Box
    30677-00100, Nairobi, Kenya
- KU: Kenyatta University, Department of Environmental Sciences
- ZEF: Center for Development research (ZEF), University of Bonn, Genscherallee 3,
    D-53113, Bonn, Germany
- INRES: University of Bonn, Department of Horticultural Sciences, Auf dem Hügel 6,
    D-53121, Bonn, Germany
link-citations: yes
linkcolor: blue
note: Replication files are available on the author's Github account (http://github.com/Issoufou-Liman).
bibliography: ./referencing_files/bibliographie.bib
spacing: double
subparagraph: yes
Keywords: Flood-based farming systems, crop modelling, customized decision support
  tools, uncertainty, Bayesian Networks, MC Simulation.
urlcolor: blue
---

```{r, include=FALSE}
options(tinytex.engine = 'xelatex')
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,out.extra = '',fig.align='center',fig.pos='!htbp',cache=TRUE)
```

```{r Message, include = FALSE, echo = FALSE, cache = FALSE}
warning("Heavy computation may be disabled. Please check the chunks!")
```

# Introduction {#I}

Modelling the performance of crops grown under specific conditions provides useful support for decision making. There are many models to simulate agricultural production [@Murthy_2004]. These models have proven useful for various science and policy applications [@Boote_et_al_1996; @Cerdan_et_al_2002]. While these models are quite sophisticated, a few complications limit their broad applicability. One important pitfalls of many models is their failure to describe reality sufficiently well to support real-life decisions [@Cerdan_et_al_2002; @Luedeling_et_al_2017]. Consequently, they fail to address their dual purpose of generating knowledge while contributing actionable information to support decisions and ultimately generate impacts [@Luedeling_et_al_2017]. These limitations of traditional modelling approaches can be explained by many issues among which their inadequacy to account for systems’ complexity, the scope of application, the available data, or customization in specific settings [@Boote_et_al_1996; @Cerdan_et_al_2002; @Luedeling_and_Shepherd_2016; @Murthy_2004; @Rotter_and_Hohn_2015; @VanIttersum_et_al_2013]. Contrastingly, the development of new models that address these challenges while producing reliable results for solving real-world problems has proven to be difficult in many contexts. In crop modelling, these problems often result in unrealistic yield assessments [@Murthy_2004; @VanIttersum_et_al_2013], which highlight the need for better approaches that accommodate for systems’ complexity and imperfect information. We argue that crop models should consider data uncertainty and find ways to include data inputs of varying nature, origin and quality. We demonstrate the usefulness and usability of this concept by developing a flexible crop model for Flood-based Farming Systems (FBFS).

FBFS are agricultural systems receiving additional irrigation from various types of non-harmful floods that are unpredictable, of short duration, of low annual frequency and occurring in relatively low-lying areas with gentle topography. In FBFS, water supply to crops is often determined by complex socio-institutional arrangements for water acquisition and sharing [@Haile_2010; @VanSteenbergen_et_al_2010]. In this contexts, floods are not natural disasters but temporary situations of excess water, driven by the natural variability as in the concept of flood pulse [@Junk_et_al_1989], or in the concept of Crue/Décrue [@Harlan_Pasquereau_1969] such that the water availability is governed by recurrent floods followed by recession providing opportunities for farming. Many authors [@FBLN_2018; @Harlan_Pasquereau_1969; @Puertas_et_al_2011; @VanSteenbergen_et_al_2011] have stressed their importance for rural livelihoods in different communities.

Water management practices in FBFS take advantage of extreme rainfall variability by saving water against potential drought. However, FBFS also pose many challenges for agricultural production [@Puertas_et_al_2011; @VanSteenbergen_et_al_2010], many of which are related to the timing, frequency or size of flood [@Puertas_et_al_2011]. These risks must be appreciated in a context of a general lack of information, which makes evidence-based management very difficult [@VanSteenbergen_et_al_2010]. The lack of information on FBFS may be due to a general lack of attention to FBFS in agricultural research and policy [@Puertas_et_al_2011; @VanSteenbergen_et_al_2010], which has limited the build-up of expertise and comprehensive information on what management practices are best suited to FBFS [@VanSteenbergen_et_al_2011]. The flood-related risks and uncertainties in information and agricultural production are too tangible to disregard. Consequently, farmers and donors are reluctant to invest in FBFS despite their productivity because of the lack of risk assessment procedures suited to FBFS. Such a decision support gap results in substantial opportunity loss in many context [@Erkossa_et_al_2014; @Hardaker_et_al_2015].

The promises of spate irrigation (a variant of FBFS) compared to rainfed agriculture has been reported in Kobo (Ethiopia) as four times and double yield increase respectively for pepper and sorghum [@VanSteenbergen_et_al_2011]. Such positive stories will, however, only materialize when the additional water is well distributed in time and complements the shortages in rainwater. Furthermore, floods may also result in excessive water, which may cause waterlogging of soils or submergence of crop canopies with negative effects on crop production. FBFS are clearly promising and complex socio-ecological systems but also prone to many risk factors and data uncertainty. In FBFS, the above-mentioned limitations of traditional modelling approaches are further exacerbated by socio-economic and management aspects that are crucial for system functioning. FBFS Models must consider sediment management, infrastructure for water acquisition, social rules and other institutional arrangements for water acquisition and sharing among farmers. While these aspects are yet to be addressed in crop models as mentioned earlier, there is so far no crop model for FBFS in our knowledge. The objective of this paper is to demonstrate how to develop a crop model for complex agricultural systems with limited information while accounting for data uncertainty. We applied decision theories methods to the concept of FBFS considering the available information and factors that seem important to ultimately simulate the performance of some crops along with their expected production risks. For the model to understand the farmers ‘realities, it needs to be able to account for qualitative as well as quantitative information. We therefore used Bayesian Networks (BNs) within a framework of Monte Carlo (MC) models to develop a crop model. The BNs were used to describe important qualitative processes, mostly related to agricultural constraints (e.g. the cropping systems and management options adopted by the farmer), and the MC models were used to describe the quantitative ones (e.g. biomass accumulation across crop development stages). FBFS are considered as showcase but the concept is customizable to any other complex systems particularly for solution-oriented research. Two study areas in Ethiopia and Kenya were selected as reference locations to produce a generic model that could be applied to many contexts with minimal modification. The two areas are assumed to provide most of the complexity (e.g. biophysical systems type, agricultural managements, social and institutional arrangements) found in FBFS.

# Study Area {#II}

The study areas, namely the Kisumu County and the Tigray region respectively in Kenya and Ethiopia, are located within relatively low-lying lands with differences regarding the management of agronomic flooding and other agricultural practices (Figure \@ref(fig:fig1)). While FBFS in Kisumu mainly source their water from permanent reservoirs via inundation canals, those in Tigray mostly obtain their water from ephemeral rivers where farmers are required to divert important amounts of spate flow within a relatively short period of time.

```{r fig1, echo=FALSE, out.width = '100%', fig.cap="Differences in the practices of FBFS in Kisumu County (Kenya) and Tigray region (Ethiopia)."}
knitr::include_graphics("figures/Modelling_FBFS_study_area.png")
```

Communities in the two study areas employ specific strategies for flood and land management (Figure \@ref(fig:fig1)). These differences were addressed by a stratified sampling frame applied during field work. In the Tigray region (Ethiopia), three schemes including Tsige’a (39.59967° N, 12.79827° E), Harosha (39.62788° N, 12.31102° E), and Dayu (39.60545° N, 12.47372° E) were sampled to capture different flood water diversion strategies. While the flood is diverted using improved water diversion in Tsige’a, traditional and modern ones are found respectively in Harosha and Dayu. Here, traditional flood water diversions are to be understood as physical infrastructures (e.g. deflecting spurs, soil bunds) constructed by the farmers across flood channels using locally available materials. In modern ones, concrete infrastructures (e.g. diversion weirs) designed by engineers replace those in traditional diversion. The improved diversion type consisted in integrating both farmers and engineer knowledge in designing the infrastructures. In Kisumu county (Kenya), where five areas (Awach Kano (0.22762° S, 34.95432° E), East Kano (0.14700° S, 34.93436° E), West Kano (0.18358° S, 34.81306° E), Out-growers (0.18822° S, 34.89974° E), East Nyankach (0.27578° S, 34.97058° E)) were considered, different situations are encountered. In Awach Kano, water is acquired via simple gravity flow from the Awach river, whereas in East Kano and West Kano it is acquired by large pumps from Nyando River and Lake Victoria, respectively. It worth mentioning that the East and West Kano schemes are conventional irrigation schemes managed by the Kenyan National Irrigation Board (NIB), even though they share many properties with FBFS. The scheme of the so called Out-growers is also fed via gravity as in the case of Awach Kano from the river Nyando, but it differs from the other locations in that it also serves as a safe disposal for excessive water in East Kano. In East Nyankach, water is obtained through runoff harvesting via various household ponds and water tanks. These differences have important implications for water supply, social organization, and crops grown under FBFS (Figure \@ref(fig:fig1)). For example, risks related to water supply may be more prominent in the Out-growers’ scheme compared to the schemes managed by the NIB. While the water sources and acquisition procedures vary under rice-based systems in Kisumu (i.e. Awach Kano, East Kano, West Kano, Out-growers), cultural practices are similar. In these areas, rice is sown (after tillage and flooding) in monocultures during floods, followed by various types of flood recession crops that are intercropped depending on the farmer and water availability (Figure \@ref(fig:fig1)). In Tigray, however, crops (mainly Maize, Sorghum, Teff) are mostly sown based on rainfall to later be irrigated using flood water (Figure \@ref(fig:fig1)).

# Materials and methods {#III}

## Conceptual Framework {#III1}

### Concepts and Rational {#III11}

The modelling concept is based on two different probabilistic approaches, the MC simulation for handling continuous variables, and the BNs for handling the discrete ones, as mentioned earlier. The resulting models, embedding complex relationships among several processes of high agricultural importance, were interfaced (Figure \@ref(fig:fig2)) to provide quantitative assessment in FBFS. Our goal was to develop a detailed description of the important processes, highlighting the factors of risk and uncertainty, that influence crops development and production focusing on various yield metrics (Figure \@ref(fig:fig2)). Towards this end, the conceptual framework (Figure \@ref(fig:fig2)) defines a farmland as the smallest entity evolving within a complex farming system where processes, fulfilling specific functions, are driven by several variables. These variables defining various biotic and abiotic factors are, in turn, moderated by a package of agricultural practices [@Jax_and_Setala_2005]. The interactions between these and the resulting low-level functions and processes profile the farmland in terms of relevant farming constraints. If the processes leading to farming constraints vary according to farmland, the variable farming constraints also varies, then they can be assessed in terms of their relative effects on crops at farm levels. Consequently, the variable farming constraint can be described using the scored values of these effects as probability distribution when these effects are measurable at plot levels, hence across the higher order farming system. Since the variables involved in the processes are causally related, the system complexity can be unambiguously dealt with by understanding the individual processes (e.g. (causality chains leading to the) available soil water or available soil nutrients) within the system. These processes, in turn, can be decomposed into the respective variables (e.g. rainfall occurrence or manure application) forming them. Furthermore, the variability in the processes across farmlands implies further state changes in the variables forming them, in which case each variable can be defined in terms of the different states (i.e. rainfall occurrence is either on-site or off-site, manure application is either true or false) it may take at farming plot levels. Such complex levels of hierarchy and categorization are the domain of multinomial models and can be well specified using BNs whereas the spatio-temporal behaviour of the system can be quantitatively assessed using MC models considering plausible sub-samples across the space of the probability distribution. With this assumption, causality chains leading to key intermediate variables were used to ultimately assess the level of farming constraints using low-level BNs estimating the probability of farming constraint at plot level. These local BNs were connected to be used as synthetic inputs for the MC model (Figure \@ref(fig:fig3); Suppl.) describing the crop development stages following the FAO nomenclature [@Allen_et_al_1998].

```{tikz fig2, echo=FALSE, fig.cap = "Conceptual framework of important processes to include in the development of a mixed model describing FBFS in Kisumu (Kenya) and Tigray (Ethiopia).", fig.ext = 'png', cache=FALSE, eval=TRUE, engine.opts = list(engine='xetex', template = "latex/tikz2pdf.tex")}
%% Beginning of Conceptual framework %%%%

\begin{tikzpicture}[node distance=0.5cm]

%%% Beginning of nodes layout %%%%

\begin{scope}[FitnodesStyle]

\node [McStyleSub, text width=5.5cm] (QuantitativeFarmlandProfileSub) {
  \begin{varwidth}{\textwidth}
  \begin {BlackBnsBullets}
  \item  available flood
  \item  available soil water
  \item  available soil nutrients
  \item  farming efficiency
  \item  pest / disease impact
  \item  etc.
  \end {BlackBnsBullets}
  \end{varwidth}
};

\node [McStyle] (QuantitativeFarmlandProfileSup)[ above=of QuantitativeFarmlandProfileSub] {
  \begin{varwidth}{\textwidth}
  \begin{center}
  Quantitative farmland profile
  \end{center}
  \begin {BlackMcBullets}
  \item  farming constraints
  \end {BlackMcBullets}
  \end{varwidth}
};

\node (QuantitativeFarmlandProfile) [draw,fit=(QuantitativeFarmlandProfileSup) (QuantitativeFarmlandProfileSub)] {};

\tcbsetmacrotowidthofnode{\mywidth}{QuantitativeFarmlandProfileSub}
% \tcbsetmacrotoheightofnode{\myheight}{QuantitativeFarmlandProfileSub}

% \draw [BraceStyle] 
%        ($(QuantitativeFarmlandProfileSub.north west)+(\mywidth pt, 0pt)$) -- ($(QuantitativeFarmlandProfileSub.north east)+(-\mywidth pt, 0pt)$);

\draw[BraceStyle] (QuantitativeFarmlandProfileSub.north west) -- (QuantitativeFarmlandProfileSub.north east);


\end{scope}

\node (McDomainSubNodes)[above=of QuantitativeFarmlandProfile, text centered, 
                         align=center, fill=white, draw=white] {MC modelling domain};

\node [draw=none, fill=none] (PlaceModelOutput) at (QuantitativeFarmlandProfileSub.east){};

\node [McStyle, text width=6.7cm] (ModelOutput) [below right= of PlaceModelOutput] {
  \begin{varwidth}{\textwidth}
  \begin{center}
  Quantitative model output for qualitative states
  \end{center}
  \begin {BlackMcBullets}
  \item  actual yield (biomass, grain)
  \item exploitable yield gap
  \item expected actual yield
  \item etc.
  \end {BlackMcBullets}
  \end{varwidth}
};

\tcbsetmacrotowidthofnode{\mywidth}{ModelOutput}
% \tcbsetmacrotoheightofnode{\myheight}{QuantitativeFarmlandProfile}

\node [McStyle, minimum width = \mywidth, text width=6.7cm] (HistoricalYield) at (QuantitativeFarmlandProfileSup.east-|ModelOutput) {
  \begin{varwidth}{\textwidth}
  \begin{center}
  Historical quantitative yield metrics
  \end{center}
  \begin {BlackMcBullets}
  \item  yield potential
  \item attainable yield potential
  \item average actual yield
  \item etc.
  \end {BlackMcBullets}
  \end{varwidth}
};

\node [McStyle, minimum width=6cm, text width = 3cm, draw=none, fill=none] (SamplingEngine) [left=of QuantitativeFarmlandProfile, text centered]{};

\node [text centered, 
       align=center, fill=white, draw=white] (ModellingInterfaceDomainSubNodes) at (SamplingEngine|-McDomainSubNodes) {Modelling interface};

\begin{scope}[FitnodesStyle]

\node [McStyle, text width=5.5cm] (QualitativeFarmlandProfileSub)[left=of SamplingEngine, align = left] {
  \begin{varwidth}{\textwidth}
  \begin{center}
  Qualitative farmland profile
  \end{center}
  \begin {BlackMcBullets}
  \item  water supply adequacy
  \item management efficiency
  \item cropping system
  \end {BlackMcBullets}
  \end{varwidth}
};

\tcbsetmacrotowidthofnode{\mywidth}{QualitativeFarmlandProfileSub}
% \tcbsetmacrotoheightofnode{\myheight}{QualitativeFarmlandProfileSub}

% \draw [BraceStyle] 
%        ($(QualitativeFarmlandProfileSub.south east)+(\mywidth pt, 0pt)$) -- ($(QualitativeFarmlandProfileSub.south west)+(-\mywidth pt, 0pt)$);

\draw[BraceStyle] (QualitativeFarmlandProfileSub.south east) -- (QualitativeFarmlandProfileSub.south west);

\node [McStyleSub] (ConstraintChance) [below=of QualitativeFarmlandProfileSub]{
  \begin{center}
  Chance of farming constraints
  \end{center}
};

\node (QualitativeFarmlandProfile)[draw,fit=(QualitativeFarmlandProfileSub) (ConstraintChance)] {};

\end{scope}

\node [BnsStyle, text width=5.28cm] (FarmManagement)[left=of QualitativeFarmlandProfile] {
  \begin{varwidth}{\textwidth}
  \begin{center}
  Farm management  
  \end{center}
  \begin {BlackBnsBullets}
  \item water management BNs
  \item management BNs
  \item etc.
  \end {BlackBnsBullets}
  \end{varwidth}
};


\node [BnsStyle, text width=4.4cm] (BioticFactors) [above=of FarmManagement] {
  \begin{varwidth}{\textwidth}
  \begin{center}
  Biotic factors 
  \end{center}
  \begin {BlackBnsBullets}
  \item pest / disease BNs
  \item crop BNs
  \item etc.
  \end {BlackBnsBullets}
  \end{varwidth}
};

\tcbsetmacrotowidthofnode{\mywidth}{BioticFactors}
\tcbsetmacrotoheightofnode{\myheight}{BioticFactors}

\node [BnsStyle, text width=4.4cm, minimum height = \myheight] (AbioticFactors)[below=of FarmManagement] {
  \begin{varwidth}{\textwidth}
  \begin{center}
  Abiotic Factors  
  \end{center}
  \begin {BlackBnsBullets}
  \item climate BNs
  \item soil BNs 
  \item etc.
  \end {BlackBnsBullets}
  \end{varwidth}
};



\node [text centered, 
       align=center, fill=white, draw=white] (BnsDomainSubNodes) at (QualitativeFarmlandProfile|-ModellingInterfaceDomainSubNodes) {BN modelling domain};

\node [fill=none, draw=none] (BnsDomainTopCheckPoint) at (BioticFactors.north) {};

\node [fill=none, draw=none] (BnsDomainBottomCheckPoint) at (AbioticFactors.south) {};

\node [fill=none, draw=none] (BnsDomainLeftCheckPoint) [left=0pt of FarmManagement] {};

\node [fill=ModellingInterfaceDomainColor, draw=ModellingInterfaceDomainColor] (ModellingInterfaceDomainTopCheckPoint) at (BnsDomainTopCheckPoint-|ModellingInterfaceDomainSubNodes) {};

\node [fill=ModellingInterfaceDomainColor, draw=ModellingInterfaceDomainColor] (ModellingInterfaceDomainBottomCheckPoint) at (BnsDomainBottomCheckPoint-|ModellingInterfaceDomainSubNodes) {};

\node [fill=McDomainColor, draw=McDomainColor] (MCDomainTopCheckPoint) at (ModellingInterfaceDomainTopCheckPoint-|McDomainSubNodes) {};

\node [fill=McDomainColor, draw=McDomainColor] (MCDomainBottomCheckPoint) at (ModellingInterfaceDomainBottomCheckPoint-|McDomainSubNodes) {};

\begin{scope}[on background layer]
\node (McBoxFrame)[McBox,fit=(MCDomainTopCheckPoint)(McDomainSubNodes)(QuantitativeFarmlandProfile)(HistoricalYield) (ModelOutput)(MCDomainBottomCheckPoint)] {};
\end{scope}

\begin{scope}[on background layer]
\node (ModellingInterfaceBoxFrame)[ModellingInterfaceBox, fit=(ModellingInterfaceDomainTopCheckPoint)(ModellingInterfaceDomainSubNodes)(SamplingEngine)(ModellingInterfaceDomainBottomCheckPoint)][left=0cm of McBoxFrame] {};
\end{scope}

\begin{scope}[on background layer]
\node (BnsInterfaceBoxFrame)[BnsBox,fit=(BnsDomainTopCheckPoint)(BnsDomainSubNodes)(BioticFactors)(FarmManagement)(AbioticFactors)(QualitativeFarmlandProfile) (ConstraintChance)(BnsDomainBottomCheckPoint)(BnsDomainLeftCheckPoint)] [left=0cm of ModellingInterfaceBoxFrame] {};
\end{scope}


%%% End of nodes layout %%%%
%%% Beginning of arrows layout %%%%

\draw[dashes] (BnsDomainSubNodes) -- (ModellingInterfaceDomainSubNodes);
\draw[dashedarrow] (ModellingInterfaceDomainSubNodes) -- (McDomainSubNodes);
\draw[thickarrow] (BioticFactors) -- (QualitativeFarmlandProfile);
\draw[thickarrow] (AbioticFactors) -- (QualitativeFarmlandProfile);
\draw[thickarrow] (FarmManagement) -- (QualitativeFarmlandProfile);
\draw[dashedarrow] (QualitativeFarmlandProfileSub) -- (QuantitativeFarmlandProfile);
%\draw[dashedarrow] (SamplingEngine) -- (QuantitativeFarmlandProfile);
\draw[thickes] (QuantitativeFarmlandProfile.south) -- ([yshift=1cm]QuantitativeFarmlandProfile|-ModelOutput.south);

% This is a hack which may not work with scaling
\shadedraw [decoration=Koch snowflake, top color=BnsDomainColor, bottom color=McDomainColor, draw=white] decorate{decorate{ decorate{ decorate{ decorate{ decorate{
  ([yshift=-1mm]QualitativeFarmlandProfile-|ModellingInterfaceDomainSubNodes.west) -- ++(60:4.2)  -- ++(300:4.2) -- ++(180:4.2)}}}}}};

\node [McStyle, minimum width=6cm, text width = 3cm, text=black, draw=none, fill=none] (SamplingEngine) [left=of QuantitativeFarmlandProfile, text centered]{\huge Random sampling engine};

\draw[thickarrow] ([yshift=1cm]QuantitativeFarmlandProfile|-ModelOutput.south) -- ([yshift=1cm]ModelOutput.south west);
\draw[thickarrow] (HistoricalYield) -- (ModelOutput);
\draw [ultra thick, lightgray](current bounding box.north west) rectangle (current bounding box.south east);
%%% End of arrows layout %%%%

\end{tikzpicture}

%% End of Conceptual framework %%%%
```

A Monte Carlo simulation is an intensive computation, where each unknown variable is estimated using mathematically valid rules, resulting in different scenario depending on the probabilities of the input data. These redundant calculations are repeated thousands of time to generate the scenario to portray the range of possible outcomes along with their probabilities. The inputs for MC models are continuous variables provided as probability distributions bounded by realistic value ranges to represent the associated uncertainty. BNs are probabilistic graphical model representing logical connections (directed edges) between a set of variables (nodes) where dependencies are represented by arrows (arcs) encoding the direction, and nature (i.e. direct or indirect relationship) of the causality [@Pearl_1988]. A Node describes the states a variable (node states) whereas a variable at the arrow head (child node) is influenced by the variable at the arrow tail (parent node). The strength of the influence is portrayed by the conditional probabilities [@Fenton_and_Neil_2013; @Jensen_1996; @Pearl_1988]. 

The properties described above make the MC models suitable for quantitative assessment [@Hubbard_2014], BNs suitable for predicting the extent to which specific effects are produced by certain causes [@Fenton_and_Neil_2013; @Jensen_1996; @Pearl_1988; @Scutari_and_Denis_2015], and both MC models and BNs suitable for imperfect information, expert knowledge, and explicit uncertainty. While MC models provide a means for quasi-exhaustive enumeration across the space of possibilities for quantitative risk assessment under uncertainty [@Rosenstock_et_al_2014], BNs are suitable for building discrete models describing different scenarios for qualitative variables [@Jensen_1996; @Pearl_1988]. We represent discrete nodes as instances of a finite set of mutually exclusive states (node states) along with their occurrence probabilities [@Jensen_1996] as conditional probability tables (CPTs; see also section \@ref(III31)) where the states of a parent node determines that of the child node [@Fenton_and_Neil_2013; @Jensen_and_Nielsen_2007; @Scutari_and_Denis_2015]. The MC model, in turn, was used for approximating probability distributions of unknown variables using probabilistic sampling by generating multiple random realisations of numerical equations aiming at quantitative biomass and grain yield assessment [@Hubbard_2014; @Luedeling_et_al_2015]. 

### Methodological Specifications {#III12}

We use an MC model to specify deterministic relationships targeting several unknown (dependent) variables (Figure \@ref(fig:fig2)) and estimate them based on random values of the known (independent) ones used as inputs for deterministic relationship linking the dependent to the independent variables [@Luedeling_et_al_2015; @Rosenstock_et_al_2014]. The BNs were used as multivariate models specifying the probabilities of the states of unknown variables conditional on the probabilities of the states of the known ones (Figure \@ref(fig:fig2)) as specified in a causal relationships between these discrete variables [@Jensen_1996; @Pearl_1988]. The MC model was based on the ‘yield gap’ concept where yield is crop-specific, primarily determined by the genetic potential of the variety, the cultivar, and the farming constraints. Yield was assumed to follow a negatively skewed gamma distribution [@Gallagher_1987; @Ramirez_et_al_2003], meaning that there are high frequency of low yield coupled with a relatively low chance of high yield values in general. The estimates for the MC model were derived relative to rainfed agriculture based the global yield gap database [@VanIttersum_et_al_2013]. We assume the yield potential to be the highest possible theoretical yield that is never achieved due to some prevailing constraints that are context-specific [@VanIttersum_et_al_2013]. Since these constraints vary at various spatial scales (e.g. at watershed level due to natural variability, at farmland scale due to management variability), losses in yield potential will also vary. Such losses can be estimated via the probability of the states of these local constraints. Then, the actual yield at a given plot is proportional to the probability of the state of local constraints at that plot. Four crops (rice, maize, sorghum and teff) were chosen based on their importance in the study areas. A high-level overview of the model is provided in section \@ref(IV1) and a more detailed description in the supplementary materials. Crop development stages were defined from the onset to 10% ground cover as initial stage, from 10% ground cover to effective full cover as the development stage, from effective full cover to the start of maturity as the mid stage, and from the start of maturity to harvest or full senescence as the late stage [@Allen_et_al_1998]. At each of these 4 stages, local BNs were used to describe the farming plot and assess the probability of farming constraints which is assumed to inform the quality of management practices employed by the farmer. The farming constraints variable, in turns, is assumed to drive several yield metrics tracing the temporal biomass accumulation and potential opportunity losses with regards to yield improvement. The yield metrics include the yield potential defined as the cultivar yield without farming constraints (i.e. limitations in water, nutrient, and stress), the exploitable yield potential defined as the fraction of yield potential (70 – 80%) achievable by the farmers, the attainable yield potential defined as the maximum achievable yield given the farmers’ realities, the average actual yield defined as the realistic yield actually achieved by the farmer, the exploitable yield gap defined as the yield improvement opportunities for the farmer, the exploitable yield gap loss due to farming constraints defined as the yield improvement opportunity loss, the actual exploited yield gap defined as the real yield improvement actually achieved by the farmer, and the expected actual yield defined as yield expectation given the farmer’s management conditions [@VanIttersum_et_al_2013]. Note, some of these metrics at the next crop development stage depend on those at the previous stage whereas a biomass expansion factor, measuring the growth rate of the crop, was considered to control the crop growth at each of these stages. This way, crops would not arbitrary grow beyond the actual yield expectations. This cross-stage interdependencies holds also for some of the variables in BNs to account for residual effects of certain variables.

## Data acquisition {#III2}

The mixed BN / MC model was structured to account for causality deemed important to FBFS settings by considering various sources of information, including literature, online databases, expert knowledge elicitation, farmer and expert interviews and remote sensing. The model development process consisted of 5 sequential steps aiming at developing theories to be contextualised with farmers’ realities (Figure \@ref(fig:fig3)). We reviewed the essential literature regarding the subject (literature review) to understand the concept, design broad leading questions, and target potential experts for interviews (high level discussion with experts). These high-level discussions provided the theoretical framework and leading questions for focus group discussions with farmers and meetings with local experts upon which individuals farmers interviews were conducted (Figure \@ref(fig:fig3)).

The literature review covered most of the flood-based livelihood network database [@FBLN_2018] and extended to other relevant sources. The high-level discussion involved 11 academic subject matter experts working with FBFS and related fields across the world. The focus group discussions, the local expert meetings and the farmer interviews were conducted in Ahero and Kisumu towns (Kenya) in December 2016 and June 2017 and Mekelle and Alamata towns (Ethiopia) in December 2016 and January 2017. Around 20 focus group discussions and 159 farmer interviews were conducted. The pool of local experts, initially represented by local farmers and extension civil servants, was extended to include the participants of the Leadership Course in Flood-Based Farming and Water Harvesting in Kenya and the participants of the International Training on Integrated Watershed Management and FBFS in Ethiopia [@FBLN_2018]. Prior to the model development exercise, the experts were taken through the principles of decision analysis, calibration training [@Hubbard_2014; @Luedeling_et_al_2015; @Whitney_et_al_2018; @Whitney_et_al_2018a] and the available data. Following the 5 steps, we adopted a procedure where participants led the discussions depending on their expertise.

```{tikz fig3, echo=FALSE, fig.cap = "Overview of the approach used to develop the crop model for FBFS in Kisumu (Kenya) and Tigray (Ethiopia).", fig.ext = 'png', cache=FALSE, eval=TRUE, engine.opts = list(engine='xetex', template = "latex/tikz2pdf.tex")}
%% Beginning of Approach Overview %%%%

\begin{tikzpicture}[node distance=1mm and 10mm]

%%% Beginning of nodes layout %%%%

\node [ModelsStyle, ultra thick,  draw = RedBnsBulletsColor, fill = white] (BnsStar) {\textbf{Bayesian}\\ \textbf{Networks}\\ \textbf{engine}};

\node [ModelsStyle, ultra thick, draw = BlueMcBulletsColor, fill = white] (McsStar) [right=0.005cm of BnsStar] {\textbf{Monte}\\ \textbf{Carlo}\\ \textbf{engine}};

\begin{scope}[on background layer]
\node (ModelStartsBoxFrame) [BnsStyle, yscale=2, fit=(McsStar)(BnsStar)] {};
\end{scope}

\node [ApproachNodesStyle, align = center] (ImportantIssues)[left= of ModelStartsBoxFrame]{Identification of important issues and causality};

\node [ApproachNodesStyle] (ResearchQuestionsFirst)[below= of ImportantIssues]{Updates of research questions and objectives};

\node [ApproachNodesStyle] (ImportantIssuesRefinitionFirst)[below= of ResearchQuestionsFirst]{Refined list of important issues and causality};

\node [ApproachNodesStyle] (MetricsEstimationFirst)[below= of ImportantIssuesRefinitionFirst]{Estimation of metrics};

\node [ApproachNodesStyle] (ImportantIssuesRefinitionSecond)[below= of MetricsEstimationFirst]{Refined list of important issues and causality};

\node [ApproachNodesStyle] (MetricsEstimationSecond)[below= of ImportantIssuesRefinitionSecond]{Estimation of metrics};

\node [ApproachNodesStyle] (ResearchQuestionsSecond)[above= of ImportantIssues]{Updates of research questions and objectives};

\node [ApproachNodesStyle] (HighLevelConcepts)[above= of ResearchQuestionsSecond]{High level concepts of FBFS};

\node [ApproachNodesStyle] (PrimaryExperts)[above= of HighLevelConcepts]{Identification of primary experts};

\node [ApproachNodesStyle] (ResearchDrafting) [above= of PrimaryExperts] {Drafting of research questions and objectives};

\node [ApproachNodesStyle] (ConceptsDefinition)[above= of ResearchDrafting]{Concept definition};

\node [fill = McDomainColor, draw=McDomainColor] (ModelDevelopmentSequenceTopCheckPoint)[above= 0pt of ConceptsDefinition]{};

\node [fill = McDomainColor, draw=McDomainColor] (ModelDevelopmentSequenceBottomCheckPoint) [below= 0pt of MetricsEstimationSecond]{};

 \begin{scope}[on background layer]
\node (ModelDevelopmentSequence)[McBox, fit=(ModelDevelopmentSequenceTopCheckPoint)(ImportantIssues)(ResearchQuestionsFirst)(ImportantIssuesRefinitionFirst)(MetricsEstimationFirst)(ImportantIssuesRefinitionSecond)(MetricsEstimationSecond)(ResearchQuestionsSecond)(HighLevelConcepts)(PrimaryExperts)(ResearchDrafting)(ConceptsDefinition)(McsStar)(BnsStar)(ModelStartsBoxFrame)(ModelDevelopmentSequenceBottomCheckPoint)] {};
\end{scope}

\begin{scope}[on background layer]
\node (ModelStartsBoxFrame)[ellipse, draw=white, fill = white, inner sep = 0pt, fit=(McsStar)(BnsStar)] {};
\end{scope}

\tcbsetmacrotowidthofnode{\mywidth}{ModelDevelopmentSequence}

\node [ApproachTitlesStyle, text width=2*\NodeTextWidth] (ModelDevelopmentApproach)[above= of ModelDevelopmentSequence|-ModelDevelopmentSequenceTopCheckPoint, minimum width = \mywidth, text height = 1cm]{\textbf{Model development approach}};

\node [ApproachNodesStyle] (LiteratureReview)[left= of ResearchDrafting]{Literature review};

\node [draw=none] (FakeNode) at ($(ResearchQuestionsSecond)!0.5!(HighLevelConcepts)$) {};

\node [ApproachNodesStyle] (HighLevelDiscussions) at(FakeNode-|LiteratureReview) {High level discussions with experts};

\node [TransitionalNodesStyle] (LeadingQuestions2Experts) at ($(LiteratureReview)!0.5!(HighLevelDiscussions)$) {\itshape\uline{Leading questions to primary experts}};

\node [draw=none] (FakeNode) at ($(ResearchQuestionsFirst)!0.5!(ImportantIssues)$) {};

\node [ApproachNodesStyle] (FarmersFGD) at (FakeNode-|LiteratureReview) {Focus group discussions with farmers};

\node [TransitionalNodesStyle] (LeadingQuestions2Farmers) at ($(HighLevelDiscussions)!0.5!(FarmersFGD)$) {\itshape\uline{Leading questions to farmers}};

\node [draw=none] (FakeNode) at ($(ImportantIssuesRefinitionFirst)!0.5!(MetricsEstimationFirst)$) {};

\node [ApproachNodesStyle] (LocalExpertsMeetings) at (FakeNode-|LiteratureReview) {Local expert meetings};

\node [TransitionalNodesStyle] (Guidance2Expert) at ($(FarmersFGD)!0.5!(LocalExpertsMeetings)$) {\itshape\uline{Guidance and checklist for expert meetings}};

\node [draw=none] (FakeNode) at ($(ImportantIssuesRefinitionSecond)!0.5!(MetricsEstimationSecond)$) {};

\node [ApproachNodesStyle] (IndividualFarmerInterviews) at (FakeNode-|LiteratureReview) {Individual farmer interviews};

\node [TransitionalNodesStyle] (Guidance2Farmers) at ($(LocalExpertsMeetings)!0.5!(IndividualFarmerInterviews)$) {\itshape\uline{Guidance and checklist for farmer interviews}}; 

\node [fill = BnsDomainColor, draw=BnsDomainColor] (DataCollectionSequenceTopCheckPoint) at (ModelDevelopmentSequenceTopCheckPoint-|LiteratureReview){};

\node [fill = BnsDomainColor, draw=BnsDomainColor](DataCollectionSequenceBottomCheckPoint) at (ModelDevelopmentSequenceBottomCheckPoint-|LiteratureReview){};

\tcbsetmacrotoheightofnode{\myheight}{ModelDevelopmentSequence}

\begin{scope}[on background layer]
\node (DataCollectionSequence)[BnsBox, minimum height = \myheight, fit=(DataCollectionSequenceTopCheckPoint)(LiteratureReview)(HighLevelDiscussions)(LeadingQuestions2Experts)(FarmersFGD)(LeadingQuestions2Farmers)(LocalExpertsMeetings)(Guidance2Expert)(Guidance2Farmers)(IndividualFarmerInterviews)(DataCollectionSequenceBottomCheckPoint)] {};
\end{scope}

\tcbsetmacrotowidthofnode{\mywidth}{DataCollectionSequence}

\node [ApproachTitlesStyle, text width=2*\NodeTextWidth] (DataCollectionApproach)[above= of DataCollectionSequence|-DataCollectionSequenceTopCheckPoint, minimum width = \mywidth, text height = 1cm]{\textbf{Data collection approach}};

% \node [draw = black, fill=black] (ClipCheckFirst) at (DataCollectionSequenceBottomCheckPoint-|DataCollectionApproach.west) {};

% \node [draw = black, fill=black] (ClipCheckSecond) at (ModelDevelopmentApproach.east){};

% \clip (ClipCheckFirst) rectangle (ClipCheckSecond){};

% \draw (DataCollectionSequence.south west) rectangle (ModelDevelopmentSequence.north east);

% \draw (ClipCheckFirst) rectangle (ClipCheckSecond){};



% \draw (ClipCheckFirst.south east) rectangle (ClipCheckSecond.north west);

%%% End of nodes layout %%%%

%%% Beginning of arrows layout %%%%

\draw[thickarrow] (ImportantIssues.east) -- (ModelStartsBoxFrame);
\draw[thickarrow] (ResearchQuestionsFirst.east) -- (ModelStartsBoxFrame);
\draw[thickarrow] (ImportantIssuesRefinitionFirst.east) -- (ModelStartsBoxFrame);
\draw[thickarrow] (MetricsEstimationFirst.east) -- (ModelStartsBoxFrame);
\draw[thickarrow] (ImportantIssuesRefinitionSecond.east) -- (ModelStartsBoxFrame);
\draw[thickarrow] (MetricsEstimationSecond.east) -- (ModelStartsBoxFrame);
\draw[thickarrow] (ResearchQuestionsSecond.east) -- (ModelStartsBoxFrame);
\draw[thickarrow] (HighLevelConcepts.east) -- (ModelStartsBoxFrame);
\draw[thickarrow] (PrimaryExperts.east) -- (ModelStartsBoxFrame);
\draw[thickarrow] (ResearchDrafting.east) -- (ModelStartsBoxFrame);
\draw[thickarrow] (ConceptsDefinition.east) -- (ModelStartsBoxFrame);

\draw[thickarrow] (IndividualFarmerInterviews.east) -- (ImportantIssuesRefinitionSecond.west);
\draw[thickarrow] (IndividualFarmerInterviews.east) -- (MetricsEstimationSecond.west);
\draw[thickarrow] (HighLevelDiscussions.east) -- (ResearchQuestionsSecond.west);
\draw[thickarrow] (HighLevelDiscussions.east)-- (HighLevelConcepts.west);
\draw[thickarrow] (FarmersFGD.east) -- (ResearchQuestionsFirst.west);
\draw[thickarrow] (FarmersFGD.east) -- (ImportantIssues.west);
\draw[thickarrow] (LocalExpertsMeetings.east) -- (ImportantIssuesRefinitionFirst.west);
\draw[thickarrow] (LocalExpertsMeetings.east) -- (MetricsEstimationFirst.west);

\draw[thickarrow] (LiteratureReview.east) -- (ConceptsDefinition.west);
\draw[thickarrow] (LiteratureReview.east) -- (ResearchDrafting.west);
\draw[thickarrow] (LiteratureReview.east) -- (PrimaryExperts.west);

\draw[thickarrow] ([xshift=3mm]LiteratureReview.south west) -- ([xshift=3mm]HighLevelDiscussions.north west);
\draw[thickarrow] ([xshift=3mm]HighLevelDiscussions.south west) -- ([xshift=3mm]FarmersFGD.north west);
\draw[thickarrow] ([xshift=3mm]FarmersFGD.south west) -- ([xshift=3mm]LocalExpertsMeetings.north west);
\draw[thickarrow] ([xshift=3mm]LocalExpertsMeetings.south west) -- ([xshift=3mm]IndividualFarmerInterviews.north west);

%%% End of nodes layout %%%%

\draw [ultra thick, lightgray](current bounding box.north west) rectangle (current bounding box.south east);

\end{tikzpicture}

%% End of Approach Overview %%%%
```

## Data processing {#III3}

### Making conditional probability tables (CPTs) {#III31}

As mentioned in section \@ref(III1), BNs are complex model in which influence between child and parent nodes are represented by arcs whereas the strength of that influence is represented by the conditional probabilities. Conditional probability tables (CPTs) are stochastic matrix storing these probabilities to portray the strength of the association between the states of a child node conditional on the probabilities of the states of its parents (e.g. probability of drought risk (available soil water node) knowing that rainfall is above normal (rainfall amount node)) [@Hansson_and_Sjokvist_2013; @Scutari_and_Denis_2015]. Specifying CPTs manually can be difficult particularly for complex nodes with many states and parents [@Hansson_and_Sjokvist_2013]. For example, a three states node with only three parents, each of which can assume 5 states, will require probability estimations for 375 possible situations. The `make_CPT` function from the decisionSupport package in R provides a shortcut for deriving CPTs relating a child node to its parents [@Luedeling_and_Goehring_2018]. The function requires the prior probability distribution of the child node, the child node sensitivity relative to the parents, the parents’ effects, and the weight of influence of each parent to create the full CPT [@Luedeling_and_Goehring_2018] using the likelihood method [@Hansson_and_Sjokvist_2013]. Estimates of all these parameters are elicited from the experts. The likelihood method is rooted in Bayes’ theorem but focuses on the likelihood instead of conditional probability. The former is easier to estimate than the latter, because expert only need to worry about a limited number of values to estimate [@Hansson_and_Sjokvist_2013; @Whitney_et_al_2018a]. For a node of interest, the method assumes the conditional probability of a given child state to be the product of the prior probability of that child state and its likelihood given the states of the parents of the node. Since the prior can also be easily estimated by the expert, the method substantially facilitates expert elicitation. With further mathematical simplifications [@Hansson_and_Sjokvist_2013], the expert only needs to provide few easier to estimate parameters for calculating the full CPT. These are the prior distribution of the child node, the base of the logarithm, a weight factor for the child node states, and a weight factor for the parent nodes states respectively corresponding to child prior, child node sensitivity, child state ranking, and the parents’ effects in the `make_CPT` function [@Hansson_and_Sjokvist_2013; @Luedeling_and_Goehring_2018].

### The models and the modelling interface {#III32}

The `make_CPT` routines were automated and interfaced with the `cptable` function from the `gRain` package [@Hojsgaard_2012], which provides architecture for computer readable graphical models, to formalise the BNs following the experts’ causal reasoning. The posterior distributions of the 3645 parameters BNs was then used as synthetic inputs to feed the MC model using a routine that recursively accounts for each state of the node farming constraints at run time. This is equivalent to sampling over all possible farming constraint scenarios. Technically, we used MC particle filters [@Kitagawa_2016; @Koller_and_Friedman_2009; @Scutari_2010] to generate the probabilities of farming constraints conditional on different combination of the states of variables involved in the BNs. The farming constraint was then used as a loss factor along with the other quantitative yield metrics (see section \@ref(III1)) to feed the MC model (Figure \@ref(fig:fig2)).

The BNs were programmed to provide the 90% confidence probability distribution, the minimal, the maximal, and the median values of the farming constraint factor. Note that the probability distributions of the node farming constraints were chosen, at each stage of crop development, based on reasonable bounds for skewness and kurtosis via visual observation supported by bootstrapping [@Delignette-Muller_and_Dutang_2015]. We fitted several candidate distributions using the `fitdist` function from the `fitdistrplus` package [@Delignette-Muller_and_Dutang_2015] from which we chose the best fitting distribution. Note also that the remaining parameters (i.e. the minimal, maximal and median values) required by the decisionSupport’s `mcSimulation` function [@Luedeling_and_Goehring_2018], which was used to conduct the MC simulation, were simply computed from the fitted distribution using the `fitdist` function and other facilities provided by the `rriskDistributions` package [@Belgorodski_et_al_2017]. The same parameters were derived for the remaining MC nodes by the experts and cross-checked against their corresponding rainfed agriculture metrics for the same areas. 

# Result {#IV}

## Overview of the Conceptual Model {#IV1}

The overview of the model is presented in Figure \@ref(fig:fig4) as mentioned in section \@ref(III). For more a detailed description, the reader is referred to the supplementary material where we provided the model specifications at the initial stage of crop development (see Suppl.). The full model along with its complex specifications (121 and 32 nodes respectively for the BNs and MC models) are provided as reproducible code in the technical material. The usefulness and usability are presented as standalone case studies to showcase the model. The 121 nodes in the main BNs were grouped into 3 local BNs at each of the 4 crop development stages and used to describe 5 important FBFS processes. These processes were then used to describe the farming constraints which was considered as quantitative node to be part of the 32 nodes of the MC model. The further modelling process includes four work streams (Figure \@ref(fig:fig4)), represented by the individual variables (e.g. soil nutrients in pink), the local BNs (e.g. cropping options in green) describing the sub-processes formed by these variables, the main BNs describing the farming constraints (in greenish yellow) to which these local BNs converge, and the crop development subject to the farming constraints (light green).

```{tikz fig4, echo=FALSE, fig.cap = "Conceptual model used to integrate the local BNs as part of a mixed model describing input allocation and agricultural management in FBFS in Kisumu (Kenya) and Tigray (Ethiopia).", fig.ext = 'png', cache=FALSE, eval=TRUE, engine.opts = list(engine='xetex', template = "latex/tikz2pdf.tex")}
%% Beginning of Overview Detailed Model %%%%

\begin{tikzpicture}[node distance = 0.5cm]

\node[BnsMultipartStyle] (UpStreamInfluence){
\nodepart{one}
On and off-site influence
\nodepart{two}
\begin{varwidth}{\textwidth}
  \begin {BlackBnsBullets}
  \item upstream abstraction
  \item rainfall occurrence
  \item etc.
  \end {BlackBnsBullets}
  \end{varwidth}
};

\node[BnsMultipartStyle] (FarmerNegotiations)[right= of UpStreamInfluence]{
\nodepart{one}
Farmer negotiations
\nodepart{two}
\begin{varwidth}{\textwidth}
  \begin {BlackBnsBullets}
  \item institutional arrangements
  \item infrastructure maintenance
  \item etc.
  \end {BlackBnsBullets}
  \end{varwidth}
};

\node[BnsMultipartStyle] (FloodingSystem)[right= of FarmerNegotiations]{
\nodepart{one}
Flooding system
\nodepart{two}
\begin{varwidth}{\textwidth}
  \begin {BlackBnsBullets}
  \item type of water diversion
  \item sediment load
  \item etc.
  \end {BlackBnsBullets}
  \end{varwidth}
};

\node[CloudyBnsStyle, draw=white, fill=white, text width=5cm] (FloodReachingPlot)[below = of FarmerNegotiations]{
Amount of flood reaching the plot
};

\node[BnsMultipartStyle] (OtherWaterFactors)[left= of FloodReachingPlot]{
\nodepart{one}
Other factors
\nodepart{two}
\begin{varwidth}{\textwidth}
  \begin {BlackBnsBullets}
  \item additional rainfall
  \item evaporation
  \item soil water holding capacity
  \item etc.
  \end {BlackBnsBullets}
  \end{varwidth}
};

\node[CloudyBnsStyle, draw=white, fill=white, text width=3cm] (AvailableSoilWater) [below right= of OtherWaterFactors]{
Available soil water
};

\node[CloudyBnsStyle, draw=white, fill=white, text width=3cm] (WaterSupplyAdequacy) [right= of FloodReachingPlot]{
Water supply adequacy
};

\node[draw=none, fill=none] (CropAndCroppingSystems) [below=5.39cm of UpStreamInfluence] {};

\node[BnsMultipartStyle] (CropAndCroppingSystems) [below=5.39cm of UpStreamInfluence] {
\nodepart{one}
Crop and cropping systems
\nodepart{two}
\begin{varwidth}{\textwidth}
  \begin {BlackBnsBullets}
  \item crop type
  \item crop variety
  \item intercropping
  \item etc.
  \end {BlackBnsBullets}
  \end{varwidth}
};

\node[CloudyBnsStyle, draw=white, fill=white, text width=3cm] (EffectivenessOfCroppingOptions) [below right =of CropAndCroppingSystems]{
Effectiveness of cropping options
};

\node[BnsMultipartStyle] (OtherAgricPractice) [below left=of EffectivenessOfCroppingOptions]{
\nodepart{one}
Other agricultural practices
\nodepart{two}
\begin{varwidth}{\textwidth}
  \begin {BlackBnsBullets}
  \item planting date
  \item previous crop
  \item etc.
  \end {BlackBnsBullets}
  \end{varwidth}
};

\node[BnsMultipartStyle] (SoilManagement)[below= 0.55cm of OtherAgricPractice]{
\nodepart{one}
Soil fertility management
\nodepart{two}
\begin{varwidth}{\textwidth}
  \begin {BlackBnsBullets}
  \item manure and amendment
  \item fertiliser application
  \item rich sediment addition
  \item etc.
  \end {BlackBnsBullets}
  \end{varwidth}
};

\tcbsetmacrotowidthofnode{\mywidth}{SoilManagement}
\tcbsetmacrotoheightofnode{\myheight}{SoilManagement}

\node[BnsMultipartStyle, fit=(SoilManagement.north west) (SoilManagement.south east), inner sep=0pt] (SoilNutrient)[right= of SoilManagement]{
\nodepart{one}
Soil fertility
};

\tcbsetmacrotowidthofnode{\mywidth}{SoilManagement}

\node[BnsMultipartStyle,minimum width=\mywidth] (SocioEconomicContext)[below= of SoilManagement]{
\nodepart{one}
Socio-economic context
\nodepart{two}
\begin{varwidth}{\textwidth}
  \begin {BlackBnsBullets}
  \item wealth status
  \item mutual assistance
  \item access to inputs
  \item etc.
  \end {BlackBnsBullets}
  \end{varwidth}
};

\node[BnsMultipartStyle] (FarmerProfile) at (SoilNutrient|-SocioEconomicContext){
\nodepart{one}
Farmer profile
\nodepart{two}
\begin{varwidth}{\textwidth}
  \begin {BlackBnsBullets}
  \item Skills of the farmer
  \item effectiveness of crop protection
  \item available labour force
  \item etc.
  \end {BlackBnsBullets}
  \end{varwidth}
};

\node[BnsMultipartStyle, align=left] (PreviousBioticStress) [below=of SocioEconomicContext]{
\nodepart{one}
Previous biotic stress
\nodepart{two}
\begin{varwidth}{\textwidth}
  \begin {BlackBnsBullets}
  \item pest \& disease sequels
  \item weeds sequels
  \item etc.
  \end {BlackBnsBullets}
  \end{varwidth}
};

\node[BnsMultipartStyle] (CurrentBioticStress) at (FarmerProfile|-PreviousBioticStress) {
\nodepart{one}
Current biotic stress
\nodepart{two}
\begin{varwidth}{\textwidth}
  \begin {BlackBnsBullets}
  \item pest and disease
  \item weeds
  \item etc.
  \end {BlackBnsBullets}
  \end{varwidth}
};

\node[CloudyBnsStyle, draw=white, fill=white, text width=3cm] (AgricManagementEfficiency) at (FarmerProfile-|WaterSupplyAdequacy){
Agricultural management efficiency
};

\node[CloudyBnsStyle, draw=white, fill=white, text width=3.5cm] (FarmingConstraints) at (EffectivenessOfCroppingOptions-|AgricManagementEfficiency){
Farming constraints (FC)
};
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\node[BnsMultipartStyle, text width = 8cm, align=left] (YieldPotential)[right= 3cm of FloodingSystem]{
\nodepart{one}
{\centering
   Yield potential\par
}
\nodepart{two}
maximum yield potential without farming constraints
};

\node[BnsMultipartStyle, text width = 8cm, align=left] (AttainbleYield) [below= of YieldPotential]{
\nodepart{one}
{\centering
    Attainable yield\par
    
}
\nodepart{two}
{achievable fraction of yield potential under ideal conditions}
};

\node[BnsMultipartStyle, text width = 8cm, align=left] (ExploitableYieldGapLoss) at (AttainbleYield|-FarmingConstraints){
\nodepart{one}
{\centering
    Exploitable yield gap loss due farming constraints\par
    
}
\nodepart{two}
{yield improvement opportunity loss due to avoidable farming constraints}
};

\node[BnsMultipartStyle, text width = 8cm, align=left] (ExploitableYieldGap) [below= of ExploitableYieldGapLoss] {
\nodepart{one}
{\centering
    Exploitable yield gap\par
}
\nodepart{two}
yield improvement opportunities for a farmer
};

\node[BnsMultipartStyle, text width = 8cm, align=left] (AverageActualYield) at (AgricManagementEfficiency-|ExploitableYieldGap){
\nodepart{one}
{\centering
    Average actual yield\par
}
\nodepart{two}
historical and realistic yield actually achieved by farmers
};

\node[BnsMultipartStyle, text width = 8cm, align=left] (BiomassExpansion)[below=of AverageActualYield]{
\nodepart{one}
{\centering
Biomass expansion factor\par
}
\nodepart{two}
account for biomass accumulation over time
};

%\node[draw=none, fill=none] (fakeNode1) at ([xshift=-1cm]SoilManagement.west|-OtherWaterFactors.west){};

%\node[draw=none, fill=none] (fakeNode2) at (SoilManagement.west-|OtherWaterFactors.west){};

%\node[draw=none, fill=none] (fakeNode2) at (SoilManagement.west-|OtherWaterFactors.west){};

\node[draw=none, fill=none](fake1) at ([xshift=-1cm]SoilManagement.west-|OtherWaterFactors.west) {};
\node[draw=none, fill=none](fake2) at (OtherWaterFactors.west-|fake1){}; 
\node[draw=none, fill=none](fake3) at ($(fake1)!0.5!(fake2)$){};
\node[draw=none, fill=none](fake4) [above=0.05cm of UpStreamInfluence]{};
\node[draw=none, fill=none](fake5) [below=0.05cm of PreviousBioticStress]{};
\node[draw=none, fill=none](fake21)[right=0.5cm of fake2]{};
\node[draw=none, fill=none](fake11)[right=0.5cm of fake1]{};
\node[draw=none, fill=none](fake31)[right=0.5cm of fake3]{};

\node[draw=none, fill=none](fake6) [right=0.05cm of FloodingSystem]{};
\node[draw=none, fill=none](fake7) at (fake6|-AgricManagementEfficiency){};
\node[draw=none, fill=none, rotate=-90, align=center, text=red](fake71) at ([xshift=0.75cm, yshift=-7.5cm]fake6|-FloodingSystem){\Huge Bayesian Networks};
\node[draw=none, fill=none](fake8) at (fake4-|YieldPotential){};
\node[draw=none, fill=none](fake9) at (fake5-|BiomassExpansion){};
\node[draw=none, fill=none](fake10)[right=1cm of ExploitableYieldGapLoss]{};
\node[draw=none, fill=none, rotate=-90, align=center, text=blue](fake101) at ([xshift=-0.9cm, yshift=-7.5cm]ExploitableYieldGapLoss.west|-YieldPotential.west){\Huge Monte Carlo model};

\begin{scope}[on background layer]
\node (BnsBox)[BnsBox, fit=(UpStreamInfluence)(FloodReachingPlot)(FloodingSystem)(FarmerNegotiations)(AvailableSoilWater)(WaterSupplyAdequacy)(OtherWaterFactors)(fake2.west)(SoilManagement)(SoilNutrient)(AgricManagementEfficiency)(CurrentBioticStress)(PreviousBioticStress)(FarmerProfile)(SocioEconomicContext)(fake1.west)(CropAndCroppingSystems)(EffectivenessOfCroppingOptions)(OtherAgricPractice)(fake3.west)(fake4.north)(fake5.south)(fake6)(fake71)] {};
\end{scope}

\begin{scope}[on background layer]
\node (BnsWaterBox)[BnsBox, draw=blue, fill=blue, opacity=0.1, fit=(UpStreamInfluence)(FloodReachingPlot)(FloodingSystem)(FarmerNegotiations)(AvailableSoilWater)(WaterSupplyAdequacy)(OtherWaterFactors)(fake4.south)(fake21)(fake6.west)] {};
\end{scope}

% \tcbsetmacrotowidthofnode{\mywidth}{BnsWaterBox}

\begin{scope}[on background layer]
\node (BnsManagementBox)[BnsBox,draw=red,fill=red, opacity=0.1, fit=(SoilManagement)(SoilNutrient)(AgricManagementEfficiency)(CurrentBioticStress)(PreviousBioticStress)(FarmerProfile)(SocioEconomicContext)(fake11)(fake7.west)] {};
\end{scope}

\begin{scope}[on background layer]
\node (BnsCropBox)[BnsBox,draw=green,fill=green,opacity=0.1, fit=(CropAndCroppingSystems)(EffectivenessOfCroppingOptions)(OtherAgricPractice)(fake31)] {};
\end{scope}

\begin{scope}[on background layer]
\node (BnsWaterBox)[McBox, fit=(YieldPotential)(AttainbleYield)(ExploitableYieldGapLoss)(ExploitableYieldGap)(AverageActualYield)(BiomassExpansion)(fake8)(fake9)(fake10)(fake101)] {};
\end{scope}

\draw[thickarrow] (UpStreamInfluence) -- (FloodReachingPlot);
\draw[thickarrow] (FarmerNegotiations) -- (FloodReachingPlot);
\draw[thickarrow] (FloodingSystem) -- (FloodReachingPlot);
\draw[thickarrow] (FloodReachingPlot) -- (AvailableSoilWater);

\draw[thickes] (AvailableSoilWater) -- ([xshift=-1cm]WaterSupplyAdequacy|-AvailableSoilWater);
\draw[thickarrow] ([xshift=-1cm]WaterSupplyAdequacy|-AvailableSoilWater) -- ([xshift=-1cm]WaterSupplyAdequacy.south);

\draw[thickarrow] (WaterSupplyAdequacy) -- (FarmingConstraints);

\draw[thickes] (CropAndCroppingSystems) -- ([xshift=-0.5cm]WaterSupplyAdequacy|-CropAndCroppingSystems);
\draw[thickarrow] ([xshift=-0.5cm]WaterSupplyAdequacy|-CropAndCroppingSystems) -- ([xshift=-0.5cm]WaterSupplyAdequacy.south);

\draw[thickarrow] (CropAndCroppingSystems) -- (EffectivenessOfCroppingOptions);
\draw[thickarrow] (EffectivenessOfCroppingOptions) -- (FarmingConstraints);
\draw[thickarrow] (OtherWaterFactors) -- (AvailableSoilWater);

\draw[thickes] (SoilManagement.west) -- (fake1.west);

\draw[thickes] (fake1.west) -- (fake2.west);

\draw[thickarrow] (fake2.west) -- (OtherWaterFactors.west);


\draw[thickarrow] (SoilManagement) -- (SoilNutrient);
\draw[thickarrow] (OtherAgricPractice) -- (EffectivenessOfCroppingOptions);
\draw[thickarrow] (AgricManagementEfficiency) -- (FarmingConstraints);
\draw[thickarrow] (CurrentBioticStress) -- (AgricManagementEfficiency);
\draw[thickarrow] (PreviousBioticStress) -- (CurrentBioticStress);
\draw[thickarrow] (FarmerProfile) -- (CurrentBioticStress);
\draw[thickarrow] (SocioEconomicContext) -- (FarmerProfile);

\draw[thickarrow] (YieldPotential) -- (AttainbleYield);
% \draw[thickarrow] (AttainbleYield) -- (ExploitableYieldGap);
\draw[thickes] ([yshift=-0.5cm]AttainbleYield.east) -- ([xshift=1cm, yshift=-0.5cm]AttainbleYield.east);

\draw[thickes] ([xshift=1cm, yshift=-0.5cm]AttainbleYield.east) -- ([xshift=1cm, yshift=0.5cm]ExploitableYieldGap.east);

\draw[thickarrow] ([xshift=1cm, yshift=0.5cm]ExploitableYieldGap.east) -- ([yshift=0.5cm]ExploitableYieldGap.east);

\draw[thickarrow] (SoilNutrient) -- (AgricManagementEfficiency);

\draw[thickarrow] (AverageActualYield) -- (ExploitableYieldGap);
% \draw[thickarrow] (BiomassExpansion) -- (AverageActualYield);
\draw[thickes] ([yshift=0.5cm]BiomassExpansion.east) -- ([xshift=1cm, yshift=0.5cm]BiomassExpansion.east);

\draw[thickes] ([xshift=1cm, yshift=0.5cm]BiomassExpansion.east) -- ([xshift=1cm, yshift=-0.5cm]ExploitableYieldGap.east);

\draw[thickarrow] ([xshift=1cm, yshift=-0.5cm]ExploitableYieldGap.east) -- ([yshift=-0.5cm]ExploitableYieldGap.east);

\draw[thickarrow] (ExploitableYieldGap) -- (ExploitableYieldGapLoss);
\draw[thickarrow] (FarmingConstraints) -- (ExploitableYieldGapLoss);

\draw [ultra thick, lightgray](current bounding box.north west) rectangle (current bounding box.south east);

\node[draw=none, fill=none, text=darkgray, text width=4.5cm, align=center] at ($(OtherAgricPractice)!0.5!(CropAndCroppingSystems)$){\Huge Cropping system module};
\node[draw=none, fill=none, text=darkgray, text width=4cm, align=center] at (OtherWaterFactors|-AvailableSoilWater) {\Huge Soil water module};
\node[draw=none, fill=none, text=darkgray, text width=5cm, align=center] [right=2mm of CurrentBioticStress]{\Huge Management module};

\node[draw=none, fill=none, text=darkgray] [below=2mm of BiomassExpansion]{\Huge Crop growth module};

\end{tikzpicture}
%% End of Overview Detailed Model %%%%
```

## Case studies {#IV2}

```{r Setting the Scene, include = FALSE, echo = FALSE, cache = FALSE}

set.seed(123)

### Installing devtools package to get decisionSupportExtra from github ####
if (!require("devtools")) {
  install.packages("devtools")
}

## Installing decisionSupportExtra and ggnomics packages from github ####
if (!require("decisionSupportExtra")) {
  devtools::install_github("Issoufou-Liman/decisionSupportExtra", build = TRUE, force = TRUE,
                           upgrade = "always", build_opts = c("--no-resave-data", "--no-manual"))

}

if (!require("ggnomics")) {
  devtools::install_github("teunbrand/ggnomics", build = TRUE, force = TRUE,
                           upgrade = "always", build_opts = c("--no-resave-data", "--no-manual"))
  }
## loading required packages ####
if (!require("pacman")) install.packages("pacman")
pacman::p_load(gRain,
               bnlearn,
               Rgraphviz,
               ggplot2,
               grid,
               gridExtra,
               decisionSupport,
               fitdistrplus,
               rriskDistributions,
               scales
)

## Loading decisionSupportExtra package ####
library(decisionSupportExtra)

## Loading the Bayesian network ####
source("source_files/BNs.R")

## removing objects that are no longer needed ####
rm(list=setdiff(ls(), "network_bn_fit"))

## A function responsable plotting the locol BNs
source("source_files/graphviz_chart_bn.R")

## some common plots specifications
legend_bg <- adjustcolor( "yellow", alpha.f = 0.15)
plots_lwd <- 0.5
min_plots_width_in <- 2.63
max_plots_width_in <- 7.5
max_plots_height_in <- 8.75
min_plots_res <- 300
plots_compression <- "lzw"
plots_font_family <- 'serif' # 'sans'
plots_font <- 1 # 2
plot_font_size <- 10

## exporting the plot to file.####
export_fun <- function(export, output_dir = "figures"){
  paste0(output_dir, '/', export, ".png")
}

my_theme <- theme_bw(base_size = plot_font_size, 
                     base_family = plots_font_family) +
  theme(
    # panel.grid.minor = element_blank(),
        # strip.background = element_blank(),
        legend.title = element_blank(),
        # remove facet spacing on x-direction
        panel.spacing = unit(0,"line"),
        
        panel.border = element_rect(fill=NA, size = 0.05),
        panel.grid.major = element_line(size = 0.05),
        panel.grid.minor = element_line(size = 0.02),
        axis.text.y = element_text(hjust = 0),
        axis.ticks = element_line(colour = 'black', size = 0.05),
        legend.position="top",
        legend.justification = 'right',
        strip.background = element_rect(fill='lightgoldenrodyellow', color = "gray", size = 0.075),
        strip.text = element_text(colour = 'black', face = 'bold'),
        strip.text.x = element_text(margin = margin(t=10, b = 10)),
        plot.title=element_text(size=10, face="bold", color="black", 
                                   margin=unit(c(0, 0, 0, 0), "pt")),
        plot.margin=unit(c(0, 0, 0, 0), "pt"),
        plot.subtitle=element_text(size=10, face="italic", color="black", 
                                   margin=unit(c(0, 0, 0, 0), "pt")))
```

### Qualitative Soil water Assessment under different Management Decisions at initial stage of crop development in Flood-based livelihood systems. {#IV21}

#### Introduction {#IV211}

FBFS are possible solutions to the increasing rainfall variability and drought in rainfed agriculture, because they can overcome water shortages through supplementary irrigation. To resolve potential drought risk, this irrigation must secure large amount of flood water in soil without creating a side effect of anaerobic conditions for crops. This requires maximizing water storage in soils (e.g. run-on, rainfall) while limiting waterlogging of soils and water loss (e.g. evapotranspiration, run-off, percolation). In FBFS, much of the water is acquired via flood, drought/waterlogging depend heavily on the amount of flood reaching the plot, and water losses are inversely related to the quality and quantity of soil organic amendments and other intrinsic factors related to soils along with other climatic factors. Depending on the soil type, farmers optimize the soil water at plot level by diverting the desired amount of flood, sometimes in combination with manure application and  mechanic works. While most farmers use one or more of such soil and water conservation techniques, few can tell which the best option is. The objective of this case study is to demonstrate how the model could be used to prescribe optimum pre-season cultural practices for improved soil water under specific soil types using the BNs sub-model. Towards this end, we queried the BNs sub-model targeting the node available soil water (`AvailSoilWater`) conditional on different combination of the states of 3 parent nodes that are relevant for soil water. The idea consisted in formulating all possible scenario accounting for each set of child-parent states relationships to ultimately investigate the chances of getting a specific state of soil water content. So doing, this study can be used a diagnosis for prescribing optimal pre-season management options in FBFS.

#### Materials and Method {#IV212}

```{r case study 1 methods rds 1,eval=TRUE, include = FALSE, echo = FALSE, cache = FALSE}

## Available soil water BNs  ####

net <- bnlearn::model2network("[SoilType][ManureApp][SoilHoldWater|SoilType:ManureApp][EvapoTranspirat][InitWaterCont][RainAmount][FloodReachsPlot][AvailSoilWater|SoilHoldWater:EvapoTranspirat:RainAmount:InitWaterCont:FloodReachsPlot]")

abbr_node_names <- bnlearn::nodes(net)

net <- bnlearn::model2network("[Soil_type][Manure_application][Soil_water_holding_capacity|Soil_type:Manure_application][Evapotranspiration_at_initial_stage][Initial_soil_water_content][Rainfall_amount_at_initial_stage][Amount_of_flood_reaching_the_plot_at_initial_stage][Available_soil_water_at_initial_stage|Soil_water_holding_capacity:Evapotranspiration_at_initial_stage:Rainfall_amount_at_initial_stage:Initial_soil_water_content:Amount_of_flood_reaching_the_plot_at_initial_stage]")

legende <- bnlearn::nodes(net)
```

```{r case study 1 methods rds 2, eval=TRUE,include=FALSE,echo=FALSE, cache=FALSE}
net <- decisionSupportExtra::extract_bn(bn = network_bn_fit, string_model = net)
if (!dir.exists("output_files")) {dir.create("output_files")}
saveRDS(net, paste0("output_files", "/", "Modelling_FBFS_BNs_Case_study_1.rds"))
```

```{r case study 1 methods rds 3, eval=TRUE,include=FALSE,echo=FALSE, cache = FALSE}
net <- readRDS("output_files/Modelling_FBFS_BNs_Case_study_1.rds")
```

```{r case study 1 methods plots, eval=TRUE, include = FALSE, echo = FALSE, cache = FALSE}

bnlearn::nodes(net) <- abbr_node_names[c(3, 1, 2, 4, 5, 6, 8, 7)]
abbr_node_names <- abbr_node_names[c(3, 1, 2, 4, 5, 6, 8, 7)]

legende <- mapply(paste, abbr_node_names, sprintf('\u2192'), legende)
legende <- gsub("_", " ",  legende)
legende <- gsub(" at initial stage", "",  legende)

leg_breaks <- list(1:3, 4:5, 6:length(legende))
legende <- lapply(leg_breaks, function(i) legende[i])
legend_pos <- c('topleft', "bottomleft", 'bottomright')
legend_title <- c("Legend (1 of 3)", "Legend (2 of 3)", "Legend (3 of 3)")

inset <- list(c(0.04, 0.08), c(0.04, 0.08), c(0.04, 0.08))
text_width_ext <- c(0.85, 0.85, 0.85)

png(export_fun(export = "Modelling_FBFS_Avail_soil_water"),
     res = min_plots_res,
     units = 'in',
     # compression = plots_compression,
     width = max_plots_width_in, 
     height = max_plots_height_in/2.75,
     pointsize = 10.5)

par(font = plots_font, family = plots_font_family, lwd=plots_lwd)

graphviz_chart_bn (x = net, type = "barprob", layout = "dot", draw.levels = TRUE,abbreviate=FALSE,
                   grid = TRUE, scale = c(max_plots_height_in/2, max_plots_width_in), col = "black", bg = "transparent",
                   text.col = "black", bar.col = "green", strip.bg = "lightyellow")

lapply(1:length(legende), function(i) {
  legend(legend_pos[i], legend = legende[[i]], text.width = text_width_ext[i]*strwidth(legende[[i]][which.max(nchar(legende[[i]]))]), 
         cex=text_width_ext[i], ncol = 1,
         bty="o", box.lwd=1, box.col='lightyellow', xjust=1, yjust=1, bg=legend_bg,
         title = legend_title[i], title.col = 'blue', inset=inset[[i]])
})

box(col = 'lightgray')
dev.off()
```

```{tikz fig5, echo=FALSE, fig.cap = "Illustration of the causality defining the factor of soil water content in FBFS in Kisumu (Kenya) and Tigray (Ethiopia).", fig.ext = 'png', cache=FALSE, eval=TRUE, engine.opts = list(engine='xetex', template = "latex/tikz2pdf.tex")}
%% Beginning of Available soil water BNs %%%%

\begin{tikzpicture}[node distance = 2cm]

\node[BnsBarplotStyle] (FloodReachsPlot2)  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Low,Medium, High}
                  ]

\addplot [AddPlotStyle]  coordinates { (0.228,Low)(0.317,Medium)     (0.455,High)};

\end{axis}
\end{tikzpicture}
};

\tcbsetmacrotowidthofnode{\mywidth}{FloodReachsPlot2}

\node[BnsBarplotTitleStyle, minimum width=\mywidth](FloodReachsPlot1)[above=0pt of FloodReachsPlot2]{Amount of flood reaching the plot};

%%%%

%%%%

\node[BnsBarplotStyle] (AvailSoilWater2)[below=of FloodReachsPlot2]  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Drought risk,Normal, Waterlogging risk}
                  ]

\addplot [AddPlotStyle]  coordinates { (0.034,Drought risk)(0.207,Normal)     (0.759,Waterlogging risk)};

\end{axis}
\end{tikzpicture}
};
\tcbsetmacrotowidthofnode{\mywidth}{AvailSoilWater2}
\node[BnsBarplotTitleStyle, minimum width=\mywidth](AvailSoilWater1)[above=0pt of AvailSoilWater2]{Available soil water};
%%%%

%%%%

\node[BnsBarplotStyle] (EvapoTranspirat2)[below=of AvailSoilWater2]  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Low,Medium, High}
                  ]

\addplot [AddPlotStyle]  coordinates { (0.100,Low)(0.200,Medium)     (0.700,High)};

\end{axis}
\end{tikzpicture}
};
\tcbsetmacrotowidthofnode{\mywidth}{EvapoTranspirat2}
\node[BnsBarplotTitleStyle, minimum width=\mywidth](EvapoTranspirat1)[above=0pt of EvapoTranspirat2]{Evapotranspiration};
%%%%


%%%%

\node[BnsBarplotStyle] (InitWaterCont2)[below left=of AvailSoilWater2]  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Very low,Low, Medium, High}
                  ]

\addplot [AddPlotStyle]  coordinates { (0.400,Very low)(0.300,Low)(0.150,Medium)     (0.150,High)};

\end{axis}
\end{tikzpicture}
};
\tcbsetmacrotowidthofnode{\mywidth}{InitWaterCont2}
\node[BnsBarplotTitleStyle, minimum width=\mywidth](InitWaterCont1)[above=0pt of InitWaterCont2]{Initial soil water content};
%%%%


%%%%

\node[BnsBarplotStyle] (RainAmount2)[above left=of AvailSoilWater2]  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Below normal,Normal, Above normal}
                  ]

\addplot [AddPlotStyle]  coordinates { (0.250,Below normal)(0.600,Normal)(0.150,Above normal) };

\end{axis}
\end{tikzpicture}
};
\tcbsetmacrotowidthofnode{\mywidth}{RainAmount2}
\node[BnsBarplotTitleStyle, minimum width=\mywidth](RainAmount1)[above=0pt of RainAmount2]{Rainfall amount};
%%%%

%%%%

\node[BnsBarplotStyle] (SoilHoldWater2)[right=of AvailSoilWater2]  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Low,Medium, High}
                  ]

\addplot [AddPlotStyle]  coordinates { (0.059,Low)(0.194,Medium)     (0.747,High)};

\end{axis}
\end{tikzpicture}
};
\tcbsetmacrotowidthofnode{\mywidth}{SoilHoldWater2}
\node[BnsBarplotTitleStyle, minimum width=\mywidth](SoilHoldWater1)[above=0pt of SoilHoldWater2]{Soil water holding capacity};
%%%%

%%%%

\node[BnsBarplotStyle] (ManureApp2)[above=of SoilHoldWater2]  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {False, True}
                  ]

\addplot [AddPlotStyle]  coordinates { (0.3,False)(0.7,True) };

\end{axis}
\end{tikzpicture}
};
\tcbsetmacrotowidthofnode{\mywidth}{ManureApp2}
\node[BnsBarplotTitleStyle, minimum width=\mywidth](ManureApp1)[above=0pt of ManureApp2]{Manure application};
%%%%

%%%%

\node[BnsBarplotStyle] (SoilType2)[below=of SoilHoldWater2]  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Sandy, Loamy, Clayey},
]

\addplot [AddPlotStyle]  coordinates { (0.050,Sandy)(0.550,Loamy)(0.400,Clayey)};

\end{axis}
\end{tikzpicture}
};
\tcbsetmacrotowidthofnode{\mywidth}{SoilType2}
\node[BnsBarplotTitleStyle, minimum width=\mywidth](SoilType1)[above=0pt of SoilType2]{Soil Type};
%%%%

\draw[thickarrow] (FloodReachsPlot2) -- (AvailSoilWater1);
\draw[thickarrow] (EvapoTranspirat1) -- (AvailSoilWater2);

\draw[thickes] (InitWaterCont1.north) -- ([yshift=-5mm]InitWaterCont1|-AvailSoilWater2);
\draw[thickarrow] ([yshift=-5mm]InitWaterCont1|-AvailSoilWater2) -- ([yshift=-5mm]AvailSoilWater2.west);

\draw[thickes] (InitWaterCont1|-RainAmount2.south) -- ([yshift=5mm]InitWaterCont1|-AvailSoilWater2);
\draw[thickarrow] ([yshift=5mm]InitWaterCont1|-AvailSoilWater2) -- ([yshift=5mm]AvailSoilWater2.west);

\draw[thickarrow] (SoilHoldWater2) -- (AvailSoilWater2);
\draw[thickarrow] (SoilType1) -- (SoilHoldWater2);
\draw[thickarrow] (ManureApp2) -- (SoilHoldWater1);

\draw [ultra thick, lightgray](current bounding box.north west) rectangle (current bounding box.south east);
\end{tikzpicture}
%% End of Available soil water BNs %%%%
```

We used the BNs part of the model to study the factor of soil water. The approach consisted in querying the local BNs describing the causality leading to the available soil water (`AvailSoilWater`) as described in Figure \@ref(fig:fig5). These are the nodes amount of flood reaching the plot (`FloodReachsPlot`) which is a direct parent (Figure \@ref(fig:fig5)), the soil type (`SoilType`) and the manure application (`ManureApp`) which are ancestors (indirect parents). We tested the effects of the different soil types (clayey, loamy, sandy), the 2 manure applications levels (true, false) and the 3 levels of amount of flood reaching the plot (too little, desired, too much). These were considered only at the initial stage of crop development as evidence based on which the BNs was queried targeting the node of interest. The resulting evidence-based posterior distributions were then used to study the probability of getting each of the 3 levels of available soil water (drought risk, normal, waterlogging risk).

#### Results and Discussions {#IV213}

A study was conducted to understand the effects of soil type, manure application and the amount of harvested flood water on the available soil water for crops at the initial stage of crop development using multiple BNs queries. The results are presented in Figure \@ref(fig:fig6).

```{r case study 1 results rds 1, eval=TRUE,include = FALSE, echo = FALSE, cache = FALSE}
## constructing the evidence list ####
evidence <- c('Soil_type', 'Manure_application', 'Amount_of_flood_reaching_the_plot_at_initial_stage')

bloks = 1:10
ssp <- sapply(bloks, function (nothing){
    out <- sample_cpdist(bn = network_bn_fit, node = "Available_soil_water_at_initial_stage",
                         op = "proba", evidence = evidence, include_relatives = FALSE)
    cbind(out$prior, out$posterior)
    
}, simplify = F, USE.NAMES = TRUE)

ssp  <- reshape::melt(ssp)
ssp$Soil_type <- factor(ssp$Soil_type, levels = unique(ssp$Soil_type))
ssp$Manure_application <- factor(ssp$Manure_application, levels = unique(ssp$Manure_application))
ssp$Amount_of_flood_reaching_the_plot_at_initial_stage <- factor(ssp$Amount_of_flood_reaching_the_plot_at_initial_stage, levels = unique(ssp$Amount_of_flood_reaching_the_plot_at_initial_stage))
ssp$variable <- factor(ssp$variable, levels = unique(ssp$variable))
```

```{r case study 1 results rds 2,eval=TRUE,include=FALSE, echo=FALSE, cache=FALSE}

saveRDS(ssp, paste0("output_files", "/", "Modelling_FBFS_ssp_Case_study_1.rds"))
```

```{r fig60,echo=FALSE,include=FALSE,fig.width=max_plots_width_in,fig.height=max_plots_height_in/4,dpi=min_plots_res}

titres <- structure(list(Soil_type = structure(1L, .Label = "Soil type", class = "factor"), 
               Manure_application = structure(1L, .Label = "Manure", class = "factor"), 
               Amount_of_flood_reaching_the_plot_at_initial_stage = structure(1L, .Label = "Floodwater", class = "factor"), 
               variable = structure(1L, .Label = "Probability of\n available soil water", class = "factor"), 
               value = structure(1L, .Label = "value", class = "factor"), 
               L1 = structure(1L, .Label = "L1", class = "factor")), class = "data.frame", row.names = c(NA, 
                                                                                                         -1L))
p1 <- ggplot(data = ssp, aes(x=L1, y = value, fill = variable))+
  # geom_boxplot(lwd = 0.05, outlier.size = 0.05)+
  geom_bar(stat="identity", position="stack")+
  ggnomics::facet_nested(.~Soil_type+Amount_of_flood_reaching_the_plot_at_initial_stage+Manure_application, 
                         space = 'free_x', scales = 'free_x')+
  scale_fill_discrete(labels = function(x) gsub("[.]", " ", x))+
  # labs(x = "Factors of available soil water", y = "Probability of soil water")+
  scale_x_discrete(breaks=1:10, expand = c(0, 0))+
  scale_y_continuous(expand = c(0, 0), breaks = seq(.25, 1, by=.25),
                     labels = function(x) sprintf("%.2f", x))+
  # scale_fill_manual(values=c("oldlace", "honeydew", "lavender"))+
  guides(color=FALSE)+
  # labs(tag = "Soil type\n Floodwater\n Manure")
  my_theme +
  # switch the facet strip label to outside 
  # remove background color
  theme(
    # strip.placement = 'outside',
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title = element_blank(),
    # axis.title = element_text(size = plot_font_size+4),
    legend.text = element_text(size = plot_font_size+2),
    legend.position = 'top',
    legend.spacing.x = unit(1.0, 'cm'),
    legend.margin=margin(0,0,0,0),
    legend.box.margin=margin(0,0,-5, 0),
    legend.key.size = unit(1,"line"),
    # panel.border = element_rect(fill=NA, size = 0.05),
    # panel.grid.major = element_line(size = 0.05),
    # panel.grid.minor = element_line(size = 0.02),
    strip.text = element_text(size = plot_font_size),
    strip.text.x = element_text(margin = margin(t=3, b = 3)),
    # strip.text.x = element_text(margin = margin(0,0,0,0, "cm")),
    # plot.tag.position = c(1, 0.9),
    # plot.tag = element_text(hjust=0),
    axis.text = element_text(size = plot_font_size+2)
  )

p2 = ggplot(data = titres, aes(x=1, y = 1, label = variable, fill=variable))+ 
  geom_text(angle = -90, size=plot_font_size-6, family=plots_font_family,lineheight = 0.9)+
  ggnomics::facet_nested(.~Soil_type+Amount_of_flood_reaching_the_plot_at_initial_stage+Manure_application,
                         space = 'free_x', scales = 'free_x')+
  theme_void(base_family = plots_font_family)+
  theme(
    
    plot.margin =margin(19.5,0,0, 0),
    # strip.background = element_rect(color = 'black', fill='white'),
        strip.text = element_text(size = plot_font_size),
    strip.text.x = element_text(margin = margin(t=3, b = 3)))

p1 <- list(p1, p2)
p1$ncol=2
p1$widths=c(12.8,1.2)

grid.newpage()
ga = do.call("grid.arrange", p1)
gb = grid.rect(.5,.5,width=unit(1,"npc"), height=unit(1,"npc"), 
               gp=gpar(lwd=1, fill=NA, col="lightgray"))
g <- gTree(children = gList(ga, gb))

```

```{r fig6,echo=FALSE,fig.width=max_plots_width_in,fig.height=max_plots_height_in/4,dpi=min_plots_res,fig.cap="Effect of soil types, manure, and flood water on the available soil water content in FBFS in Kisumu (Kenya) and Tigray (Ethiopia). For each block, the 10 bars represent the 10 model runs"}

grid.draw(g)

ggsave(plot=g, device = 'png', filename = "figures/Modelling_FBFS_factor_of_soil_water.png", width = max_plots_width_in, 
       height =max_plots_height_in/3, units = "in", dpi = min_plots_res
)
```
Under clayey soils without manure application, drought risk and normal soil water conditions are unlikely, with similar level of certainty, contrary to waterlogging when, at least, the desired amount of flood is expected. In years with potentially too little floods, the chances of waterlogging and normal soil water conditions are nearly equally likely with probabilities slightly below 0.5 against a chance over 10 for drought. The uncertainty is relatively higher when little amount of flood is expected. Supplementary manure application increases the chance of waterlogging with higher certainty when too much flood is expected. The chances of normal condition are seen reduced with lower certainty when a desired amount of flood is expected. In a nutshell, manure application for water management in FBFS with clayey soils may not be necessary when a least of desired flood amount is expected. Crops supporting anaerobic conditions (e.g. rice) are recommended unless when too little flood is predicted.

Loamy soils generally behave similarly to clayey ones with slightly lower chance of waterlogging in favor of normal soil water conditions. Drought is still unlikely with slightly higher chance. Waterlogging still dominate loamy soils, particularly with manure amendments. An important difference with clayey soils is that normal soil water conditions are more likely without manure application when little flood is expected even though the chance hardly reach 50%. With manure supplements, however, the situation is reversed with waterlogging slightly taking the lead, but the highest chance remains below 50%. In general, the uncertainty seems to be reducing with manure application and higher flood amount compared to clayey soils. The same crop recommendations, as in the case the case of clayey soils, can be prescribed for loamy soils. However, manure application can be justified herein, particularly when too little flood amount is expected or when the farmer plans to grow high water demanding crops.

Sandy soils seems to be the riskiest and most uncertain soils type for FBFS. The uncertainty, nonetheless, seems to be reducing with better flood and manure application. In general, normal conditions dominate sandy soils in FBFS. However, drought is likely in years with little flood and manure application.  With good manure application, nonetheless, waterlogging can be expected in years with high flood expectations. For this soil type, good level of organic matter and drought tolerant crops are recommended. In any case, high water demanding crops can be risky.

### Probabilistic Assessment of Biomass Accumulation in Major Crops grown under FBFS in Kisumu, Kenya and Tigray, Ethiopia. {#IV22}

#### Introduction {#IV221}

Apart from their substantial contribution to food security, FBFS also provide extensive amounts of fodder and post-harvest grazing opportunities for livestock in many areas. In both the Tigray region and Kisumu County, livestock feed on crop residues and other flood recession grasses, which make substantial contributions to livestock production. The symbiotic relationship between crops and livestock are well known and common to many farming systems. While the crop biomass contribution is substantial for livestock, biomass yield is often overlooked in favour of grain yield by many crop models. This case study provides a purely probabilistic attempt towards using the model for assessing the expected biomass yield and other important biomass yield metric (e.g. biomass yield gap, exploited biomass yield). By providing these estimates at different stages of crop development, the model may also serve as tool for monitoring biomass accumulation over the growing season.

#### Materials and Method {#IV222}

We used the model as described in section \@ref(III3) to simulate the biomass yield at both the initial and late stage of crop development. In this lumped assessment, all possible scenarios across the different nodes specified in the BNs were considered. With the 3 states for each of the 4 nodes describing the farming constraints at different development stages (section \@ref(III1)), and the 4 metrics considered (i.e. exploitable yield gap, exploitable yield gap loss due to constraints, actual exploited yield gap, and expected actual yield), the model simulation produced 324 ($324 = 3\times3\times3\times4$) results corresponding to the space of possibilities. Only a few of these results are presented here to showcase the model. We selected the initial and the late stages of crop development along with the worst, the medium, and best cases scenario to respectively show the biomass accumulation over time, and the effect of varying farming constraints on crop development.

```{tikz fig7, echo=FALSE, fig.cap = "MC model describing important variables as part of a mixed model describing the expected crop yield at different stages of crop development in FBFS in Kisumu (Kenya) and Tigray (Ethiopia).", fig.ext = 'png', cache=FALSE, eval=TRUE, engine.opts = list(engine='xetex', template = "latex/tikz2pdf.tex")}

%% Beginning of Simplified Monte Carlo Model %%%%

\begin{tikzpicture}

\arrayrulecolor{white}

\node[FlexMcStyle, draw=BlueMcBulletsColor, fill=white] (ExpectedActualYieldDev) {
\begin{tabular}{c}
 \hline
 \rowcolor{graphicbackground}
 {\LARGE\bf Expected actual yield $(ExpectYaDev)$}\\ \hline \hline
  \rowcolor{McDomainColor}
$ActualExplYgDev + (ExpectYaInit \times ExpDev)$ \\ \hline
\end{tabular}
};

\node[FlexMcStyle, draw=ModellingInterfaceDomainColor, fill=white] (ExpectedActualYieldInit)[right=of ExpectedActualYieldDev] {
\begin{tabular}{c}
\hline 
\rowcolor{graphicbackground}
{\LARGE\bf Expected actual yield $(ExpectYaInit)$}\\ \hline \hline
\rowcolor{McDomainColor}
 $ActualExplYgInit + AvgYaInit$\\ \hline
\end{tabular}
};

\node[FlexMcStyle, dashed, draw=ModellingInterfaceDomainColor, fill=white] (AverageActualYieldInit)[above left=of ExpectedActualYieldInit] {
\begin{tabular}{c | c}
% \begin{minipage}{2.5cm}
\hline 
\rowcolor{graphicbackground}
\multicolumn{2}{c}{\LARGE\bf Average actual yield $(AvgYaInit)$}\\ \hline \hline
\rowcolor{McDomainColor}
{Minimum} & {0.04} \\ 
\rowcolor{McDomainColor}
{Median} & {0.26} \\
\rowcolor{McDomainColor}
{Maximum} & {0.76} \\ 
\rowcolor{McDomainColor}
{Probability distribution} & {gamma}\\ \hline
% \end{minipage}
\end{tabular}
};

\draw[thickarrow] (AverageActualYieldInit.south east) to [bend right = 20](ExpectedActualYieldInit.north west);

\draw[thickarrow] (ExpectedActualYieldInit.west) -- (ExpectedActualYieldDev.east);

\node[FlexMcStyle, draw=ModellingInterfaceDomainColor, fill=white] (ActualExploitedYieldgapInit)[right= of ExpectedActualYieldInit.north east|-AverageActualYieldInit] {
\begin{tabular}{c}
\hline 
\rowcolor{graphicbackground}
{\LARGE\bf Actually exploited yield gap $(ActualExplYgInit)$}\\ \hline \hline
\rowcolor{McDomainColor}
 $ExplYgInit - YgLossInit$\\ \hline
\end{tabular}
};


\node[FlexMcStyle, draw=ModellingInterfaceDomainColor, fill=white] (ExploitableYieldGapInit) [above right=of AverageActualYieldInit] {
\begin{tabular}{c}
\hline
\rowcolor{graphicbackground}
{\LARGE\bf Exploitable yield gap $(ExplYgInit)$}\\ \hline \hline
\rowcolor{McDomainColor}
 $AttainYpInit - AvgYaInit$\\ \hline
\end{tabular}
};

\node[FlexMcStyle, draw=BlueMcBulletsColor, fill=white] (ExploitableYieldGapDev) at ($(ExploitableYieldGapInit)!0.5!(ExpectedActualYieldInit)$) {
\begin{tabular}{c}
\hline 
\rowcolor{graphicbackground}
{\LARGE\bf Exploitable yield gap $(ExplYgDev)$}\\ \hline \hline
\rowcolor{McDomainColor}
 $ExplYgInit + (ExplYgInit \times ExpDev)$\\ \hline
\end{tabular}
};

\node[FlexMcStyle, draw=BlueMcBulletsColor, fill=white] (ExploitableYieldGapLossDue2ConstraintsDev)[below right= 1.5cm and 4cm of ExpectedActualYieldDev] {
\begin{tabular}{c}
\hline 
\rowcolor{graphicbackground}
{\LARGE\bf Exploitable yield gap loss due to constraints $(YgLossDev)$}\\ \hline \hline
\rowcolor{McDomainColor}
 $ExplYgDev \times FcDev$\\ \hline
\end{tabular}
};

\node[FlexMcStyle, draw=BlueMcBulletsColor, fill=white] (ActualExploitedYieldgapDev)[left=of ExploitableYieldGapInit] {
\begin{tabular}{c}
\hline 
\rowcolor{graphicbackground}
{\LARGE\bf Actually exploited yield gap $(ActualExplYgDev)$}\\ \hline \hline
\rowcolor{McDomainColor}
 $ExplYgInit - ExplLossDev$\\ \hline
\end{tabular}
};

\draw[thickarrow] ([xshift = -4cm]ActualExploitedYieldgapDev.south-|ExpectedActualYieldDev) to ([xshift = -4cm]ExpectedActualYieldDev.north);

\node[FlexMcStyle, draw=ModellingInterfaceDomainColor, fill=white] (ExploitableYieldGapLossDue2ConstraintsInit)[right= of ExploitableYieldGapInit] {
\begin{tabular}{c}
\hline 
\rowcolor{graphicbackground}
{\LARGE\bf Exploitable yield gap loss due to constraints $(YgLossInit)$}\\ \hline \hline
\rowcolor{McDomainColor}
 $ExplYgInit \times FcInit$\\ \hline
\end{tabular}
};

\node[FlexMcStyle,  dashed, draw=ModellingInterfaceDomainColor, fill=white] (YieldPotential)[above= of ExploitableYieldGapLossDue2ConstraintsInit] {
\begin{tabular}{c | c}
\hline
\rowcolor{graphicbackground}
\multicolumn{2}{c}{\LARGE\bf Yield potential $(YpInit)$}\\ \hline \hline
\rowcolor{McDomainColor}
{Minimum} & {0.08} \\ 
\rowcolor{McDomainColor}
{Median} & {0.96} \\
\rowcolor{McDomainColor}
{Maximum} & {3.85} \\  
\rowcolor{McDomainColor}
{Probability distribution} & {gamma}\\ \hline
\end{tabular}
};

\node[FlexMcStyle, dashed, draw=ModellingInterfaceDomainColor, fill=white] (ExploitableYieldPotentialInit)[above= of ActualExploitedYieldgapDev] {
\begin{tabular}{c | c}
\hline
\rowcolor{graphicbackground}
\multicolumn{2}{c}{\LARGE\bf Exploitable yield potential $(ExplYpInit)$}\\ \hline \hline
\rowcolor{McDomainColor}
{Minimum} & {0.85} \\ 
\rowcolor{McDomainColor}
{Median} & {0.89} \\
\rowcolor{McDomainColor}
{Maximum} & {0.90} \\
\rowcolor{McDomainColor}
{Probability distribution} & {unif}\\ \hline
\end{tabular}
};

\node[FlexMcStyle, draw=ModellingInterfaceDomainColor, fill=white] (AttainableYieldPotential) at ($(YieldPotential)!0.5!(ExploitableYieldPotentialInit)$) {
\begin{tabular}{c}
\hline 
\rowcolor{graphicbackground}
{\LARGE\bf Attainable yield potential $(AttainYpInit)$}\\ \hline \hline
\rowcolor{McDomainColor}
{$YpInit \times ExplYpInit$}\\ \hline
\end{tabular}
};

\node[FlexMcStyle,  dashed, draw=BlueMcBulletsColor, fill=white] (BiomassExpansionDev)[right= of ExpectedActualYieldInit] {
\begin{tabular}{c | c}
\hline 
\rowcolor{graphicbackground}
\multicolumn{2}{c}{\LARGE\bf Biomass expansion factor $(ExpDev)$}\\ \hline \hline
\rowcolor{McDomainColor}
{Minimum} & {0.27} \\ 
\rowcolor{McDomainColor}
{Median} & { } \\
\rowcolor{McDomainColor}
{Maximum} & {0.68} \\
\rowcolor{McDomainColor}
{Probability distribution} & {gamma}\\ \hline
\end{tabular}
};

\node[CloudyBnsStyle, draw=ModellingInterfaceDomainColor, fill=white] (FarmingConstraintsInit) [right= of YieldPotential] {\LARGE\bf Farming\\\LARGE\bf constraints\\$(FcInit)$};

\node[draw=none, fill=none] (corner1) at ($(ExploitableYieldGapLossDue2ConstraintsDev.north west)!0.5!(ExpectedActualYieldInit.south)$) {};

\node[draw=none, fill=none] (corner2) at (corner1-|ExpectedActualYieldDev.south west) {};

\node[draw=none, fill=none] (corner3) at (corner2|-ActualExploitedYieldgapDev.west) {};

\node[CloudyBnsStyle, draw=BlueMcBulletsColor, fill=white] (FarmingConstraintsDev) at (ExploitableYieldGapLossDue2ConstraintsDev-|FarmingConstraintsInit) {\LARGE\bf Farming\\\LARGE\bf constraints\\$(FcDev)$};

\node [McStyle, text width =15cm] (note1)[left=of ExploitableYieldGapLossDue2ConstraintsDev] {
\begin{varwidth}{\textwidth}
\begin{center}
Note:
\end{center}
\end{varwidth}
\begin {GrayModellingInterfaceBullets}
 \item Gray-bordered nodes are taken at initial stage.
\end {GrayModellingInterfaceBullets}
\begin {BlueMcBullets}
 \item Blue-bordered nodes are taken at development stage.
\end {BlueMcBullets}
\begin {BlackMcBullets}
 \item Dashed and plain lines nodes, respectively, are elicited and computed.
\end {BlackMcBullets}
};


%\draw[thickarrow] ([xshift=1cm]ExploitableYieldGapLossDue2ConstraintsDev.north west) -- (corner1.south) -- (corner2.south west) -- (corner3.west) -- (ActualExploitedYieldgapDev.west);

\draw[thickarrow] ([xshift=1cm]ExploitableYieldGapLossDue2ConstraintsDev.north west) -- (corner1.south) -- (corner2.south west) -- (ActualExploitedYieldgapDev.south-|corner2.south west);

\draw[thickarrow, name path=BiomassExpansionDev--ExpectedActualYieldDev] (BiomassExpansionDev.west|-corner1.west) -- (corner1.west) -- (corner2.west-|ExpectedActualYieldDev) -- (ExpectedActualYieldDev);

\draw[thickarrow, name path=BiomassExpansionDev--ExploitableYieldGapDev] (BiomassExpansionDev.north west) to [bend right=10](ExploitableYieldGapDev.east);

%\draw[thickes] (FarmingConstraintsInit.east) -- (ExploitableYieldGapLossDue2ConstraintsInit.south|-FarmingConstraintsInit.east);

%\draw[thickarrow] (ExploitableYieldGapLossDue2ConstraintsInit.south|-FarmingConstraintsInit.east) -- (ExploitableYieldGapLossDue2ConstraintsInit.south);

\draw[thickarrow] (FarmingConstraintsInit.south) -- (ExploitableYieldGapLossDue2ConstraintsInit.north-|FarmingConstraintsInit.south);

\draw[thickarrow] (ExploitableYieldGapLossDue2ConstraintsInit.south) -- (ActualExploitedYieldgapInit.north-|ExploitableYieldGapLossDue2ConstraintsInit.south);

\draw[thickarrow] (ExploitableYieldGapInit.east) -- (ExploitableYieldGapLossDue2ConstraintsInit.west);

\draw[thickarrow] (ExploitableYieldGapInit.south east) to [bend left=20](ActualExploitedYieldgapInit.north west);

\draw[thickarrow] (AverageActualYieldInit.north east) to [bend left=20] (ExploitableYieldGapInit.south west);

\draw[thickarrow] (YieldPotential) -- (AttainableYieldPotential);

\draw[thickarrow] (ExploitableYieldPotentialInit) -- (AttainableYieldPotential);

\draw[thickarrow] (AttainableYieldPotential.south-|ExploitableYieldGapInit) -- (ExploitableYieldGapInit);

\draw[thickarrow] (ExploitableYieldGapInit.south-|AttainableYieldPotential.south-|ExploitableYieldGapInit) -- (ExploitableYieldGapDev.north-|AttainableYieldPotential.south-|ExploitableYieldGapInit);

\draw[thickarrow] (ExploitableYieldGapInit) -- (ActualExploitedYieldgapDev); 

%\draw[thickarrow, name path=ExploitableYieldGapDev--ExploitableYieldGapLossDue2ConstraintsDev] (ExploitableYieldGapDev.south east) to [bend left=10]([xshift=-0.5cm]ExploitableYieldGapLossDue2ConstraintsDev.north); 
\draw[thickarrow, name path=ExploitableYieldGapDev--ExploitableYieldGapLossDue2ConstraintsDev] (ExploitableYieldGapDev.south east) to [bend left=30]([xshift=0cm]ExploitableYieldGapLossDue2ConstraintsDev.north); 
\draw[thickarrow, name path=ActualExploitedYieldgapInit--ExpectedActualYieldInit] (ActualExploitedYieldgapInit.south west) to [bend left = 20](ExpectedActualYieldInit.north east);

\path [name intersections={of=BiomassExpansionDev--ExploitableYieldGapDev and ActualExploitedYieldgapInit--ExpectedActualYieldInit, by={A}}];
\path [name intersections={of=ExploitableYieldGapDev--ExploitableYieldGapLossDue2ConstraintsDev and ActualExploitedYieldgapInit--ExpectedActualYieldInit, by={B}}];
\path [name intersections={of=BiomassExpansionDev--ExpectedActualYieldDev and ExploitableYieldGapDev--ExploitableYieldGapLossDue2ConstraintsDev, by={C}}];

\node[rectangle, draw=white, fill=white] at (A) { };
\node[rectangle, draw=white, fill=white] at (B) { };
\node[rectangle, draw=white, fill=white] at (C) { };

\draw[thickarrow, name path=ActualExploitedYieldgapInit--ExpectedActualYieldInit] (ActualExploitedYieldgapInit.south west) to [bend left = 20](ExpectedActualYieldInit.north east);

\draw[thickarrow, name path=BiomassExpansionDev--ExpectedActualYieldDev] (BiomassExpansionDev.west|-corner1.west) -- (corner1.west) -- (corner2.west-|ExpectedActualYieldDev) -- (ExpectedActualYieldDev);


%BiomassExpansionDev--ExploitableYieldGapDev
%ExploitableYieldGapDev--ExploitableYieldGapLossDue2ConstraintsDev
%ActualExploitedYieldgapInit--ExpectedActualYieldInit


%\draw[thickes] (FarmingConstraintsDev.west) -- ([xshift=1cm]ExploitableYieldGapLossDue2ConstraintsDev.south west|-FarmingConstraintsDev.west);

%\draw[thickarrow] ([xshift=1cm]ExploitableYieldGapLossDue2ConstraintsDev.south west|-FarmingConstraintsDev.west) -- ([xshift=1cm]ExploitableYieldGapLossDue2ConstraintsDev.south west);

\draw[thickarrow] (FarmingConstraintsDev) -- (ExploitableYieldGapLossDue2ConstraintsDev);

\draw [ultra thick, lightgray](current bounding box.north west) rectangle (current bounding box.south east);

\end{tikzpicture}
%% End of Simplified Monte Carlo Model %%%%
```

#### Results and Discussions {#IV223}

The simulated actual biomass yield along with other yield metrics are presented in Figure \@ref(fig:fig7) and Figure \@ref(fig:fig9). As it can be seen there are clearly important risks in FBFS practice in the study areas. In general yield / yield gain vary according to farming constraints with relatively higher chance of low biomass with increasing farming constraints. While the variability is substantial with time and varying level of farming constraints, the distributions have not changed much.

Based on the 90% confidence intervals, the exploitable yield gap, the actual exploited yield gap, and the expected yield can nearly double between high and low farming constraints contrary to the yield opportunity loss. These have also exhibited interesting change with time. Zero chances of yield opportunity loss, which seems to have tied distribution and little change with time, are plausible with minimal farming constraints.  However, there seems to be more of possibilities for high gains than there are for high losses in terms of exploitable yield gaps, and this has not much changed with time. In a nutshell, based on the 90% confidence interval, there are possibilities for substantial increases in biomass yields biomass yield regardless of the level of the farming constraints. This increase, however, seems to be more important moving from high to medium level of constraints than it is between the medium and the low level. 

```{r case study 2 Results rds, eval=TRUE, include = FALSE, echo = FALSE, cache = FALSE}

## Obversed and potential grain yield for various rainfed crops near kisumu county and tigray region ####
source("data_files/yield.R")

## relative biomass accumulation accross development stages
stage_ratio = c(initial_stage = 0.10,  development_stage = 0.80, mid_stage = 0.95, late_stage = 1)

## proportion of grain yield relative to biomass yield #####
harvest_index = c(0.1, 0.3)

## A function for making an informed guess of biomass yield at each stage ####
## This can also be used as checklist for the final prediction
guess_biomass_yield <- function(grain_yield_pot, 
                               # harvest_index = c(0.1, 0.3),
                               stage_ratio = c(initial_stage = 0.10,  development_stage = 0.80, mid_stage = 0.95, late_stage = 1)){
  # harvest_index <- runif(1000, harvest_index[1], harvest_index[2]) #
  # total_biomass_pot <- sapply(harvest_index, function(i){
  #   grain_yield_pot/i
  # })
  
  total_biomass_pot <- sapply(stage_ratio, function (i){
    # total_biomass_pot*i
    grain_yield_pot*i
  }, simplify = TRUE, USE.NAMES = TRUE)
  as.data.frame(na.omit(total_biomass_pot))
}


# bn nodes estimates ####

Local_constraints_at_initial_stage_estimates <- make_node_states_estimates(bn=network_bn_fit, node='Local_constraints_at_initial_stage', op = 'proba', distr = 'beta', state_effects = c(0.9, 0.6, 0.1)) # , state_effects = c(0.9, 0.6, 0.1) # c(0.6, 0.3, 0.1)
Local_constraints_at_development_stage_estimates <- make_node_states_estimates(bn=network_bn_fit, node='Local_constraints_at_development_stage', op = 'proba', distr = 'beta', state_effects = c(0.9, 0.6, 0.1))
Local_constraints_at_mid_stage_estimates <- make_node_states_estimates(bn=network_bn_fit, node='Local_constraints_at_mid_stage', op = 'proba', distr = 'beta', state_effects = c(0.9, 0.6, 0.1))
Local_constraints_at_late_stage_estimates <- make_node_states_estimates(bn=network_bn_fit, node='Local_constraints_at_late_stage', op = 'proba', distr = 'beta', state_effects = c(0.9, 0.6, 0.1))

## yield potential estimate #####
mc_nodes_estimates_biomass_yield_pot <- guess_decisionSupport_estimates (data = list(potential_grain_yield, 
                                                                                     # harvest_index = harvest_index, 
                                                                                     stage_ratio = stage_ratio), 
                                                                         fun = guess_biomass_yield,
                                                                         distr = rep('gamma', 4), 
                                                                         percentiles = c(0.025, 0.5, 0.975), 
                                                                         plot = FALSE, show.output = FALSE)
rownames(mc_nodes_estimates_biomass_yield_pot$marginal) <- paste0('biomass_Yield_Pot_', rownames(mc_nodes_estimates_biomass_yield_pot$marginal))

## Attainable yield estimates : Median, Lowest and Highest ####

mc_nodes_lower_exploitable_biomass_yield_pot <- data.frame(lower = c(initial_stage = 0.85-0.35, mid_stage = 0.80-0.35, development_stage = 0.75-0.35, late_stage = 0.70-0.35),
                                                           median = c(initial_stage = 0.89-0.35, mid_stage = 0.87-0.35, development_stage = 0.80-0.35, late_stage = 0.71-0.35),
                                                           upper = c(initial_stage = 0.90-0.35, mid_stage = 0.90-0.35, development_stage = 0.90-0.35, late_stage = 0.90-0.35),
                                                           distribution = c(initial_stage = 'unif', mid_stage = 'unif', development_stage = 'unif', late_stage = 'unif'),
                                                           method = c(initial_stage = 'fit', mid_stage = 'fit', development_stage = 'fit', late_stage = 'fit'),
                                                           stringsAsFactors = FALSE)

rownames(mc_nodes_lower_exploitable_biomass_yield_pot) <- paste0('lower_exploitable_biomass_yield_pot_', rownames(mc_nodes_lower_exploitable_biomass_yield_pot))
mc_nodes_lower_exploitable_biomass_yield_pot <- as.estimate(mc_nodes_lower_exploitable_biomass_yield_pot)

mc_nodes_mid_exploitable_biomass_yield_pot <-  data.frame(lower = c(initial_stage = 0.85-0.15, mid_stage = 0.80-0.15, development_stage = 0.75-0.15, late_stage = 0.70-0.15),
                                                          median = c(initial_stage = 0.89-0.15, mid_stage = 0.87-0.15, development_stage = 0.80-0.15, late_stage = 0.71-0.15),
                                                          upper = c(initial_stage = 0.90-0.15, mid_stage = 0.90-0.15, development_stage = 0.90-0.15, late_stage = 0.90-0.15),
                                                          distribution = c(initial_stage = 'unif', mid_stage = 'unif', development_stage = 'unif', late_stage = 'unif'),
                                                          method = c(initial_stage = 'fit', mid_stage = 'fit', development_stage = 'fit', late_stage = 'fit'),
                                                          stringsAsFactors = FALSE)

rownames(mc_nodes_mid_exploitable_biomass_yield_pot) <- paste0('mid_exploitable_biomass_yield_pot_', rownames(mc_nodes_mid_exploitable_biomass_yield_pot))
mc_nodes_mid_exploitable_biomass_yield_pot <- as.estimate(mc_nodes_mid_exploitable_biomass_yield_pot)


mc_nodes_upper_exploitable_biomass_yield_pot <- data.frame(lower = c(initial_stage = 0.85, mid_stage = 0.80, development_stage = 0.75, late_stage = 0.70),
                                                           median = c(initial_stage = 0.89, mid_stage = 0.87, development_stage = 0.80, late_stage = 0.71),
                                                           upper = c(initial_stage = 0.90, mid_stage = 0.90, development_stage = 0.90, late_stage = 0.90),
                                                           distribution = c(initial_stage = 'unif', mid_stage = 'unif', development_stage = 'unif', late_stage = 'unif'),
                                                           method = c(initial_stage = 'fit', mid_stage = 'fit', development_stage = 'fit', late_stage = 'fit'),
                                                           stringsAsFactors = FALSE)
rownames(mc_nodes_upper_exploitable_biomass_yield_pot) <- paste0('upper_exploitable_biomass_yield_pot_', rownames(mc_nodes_upper_exploitable_biomass_yield_pot))
mc_nodes_upper_exploitable_biomass_yield_pot <- as.estimate(mc_nodes_upper_exploitable_biomass_yield_pot)

mc_nodes_exploitable_biomass_yield_pot <- list(mc_nodes_lower_exploitable_biomass_yield_pot, mc_nodes_mid_exploitable_biomass_yield_pot, mc_nodes_upper_exploitable_biomass_yield_pot)

## Average yield estimates: Median, Lowest and Highest ####

cond <- get_boxplot_range_1d (observed_actual_grain_yield)
mc_nodes_lower_average_actu_biomass_yield <- observed_actual_grain_yield[observed_actual_grain_yield >= cond[1] & observed_actual_grain_yield < cond[3]]
mc_nodes_mid_average_actu_biomass_yield <- observed_actual_grain_yield[observed_actual_grain_yield >= cond[3] & observed_actual_grain_yield < cond[5]]
mc_nodes_upper_average_actu_biomass_yield <- observed_actual_grain_yield[observed_actual_grain_yield >= cond[5] & observed_actual_grain_yield < cond[7]]

mc_nodes_lower_average_actu_biomass_yield <- guess_decisionSupport_estimates (data = list(mc_nodes_lower_average_actu_biomass_yield, 
                                                                                          # harvest_index = harvest_index,
                                                                                          stage_ratio = stage_ratio), fun=guess_biomass_yield, distr = rep('gamma', 4),
                                                                              percentiles = c(0.025, 0.5, 0.975), plot = FALSE, show.output = FALSE)
rownames(mc_nodes_lower_average_actu_biomass_yield$marginal) <- paste0('lower_average_Actual_yield_', rownames(mc_nodes_lower_average_actu_biomass_yield$marginal))


mc_nodes_mid_average_actu_biomass_yield <- guess_decisionSupport_estimates (data = list(mc_nodes_mid_average_actu_biomass_yield, 
                                                                                        # harvest_index = harvest_index,
                                                                                        stage_ratio = stage_ratio), fun=guess_biomass_yield, distr = rep('gamma', 4),
                                                                            percentiles = c(0.025, 0.5, 0.975), plot = FALSE, show.output = FALSE)
rownames(mc_nodes_mid_average_actu_biomass_yield$marginal) <- paste0('mid_average_Actual_yield_', rownames(mc_nodes_mid_average_actu_biomass_yield$marginal))


mc_nodes_upper_average_actu_biomass_yield <- guess_decisionSupport_estimates (data = list(mc_nodes_upper_average_actu_biomass_yield, 
                                                                                          # harvest_index = harvest_index,
                                                                                          stage_ratio = stage_ratio), fun=guess_biomass_yield, distr = rep('gamma', 4),
                                                                              percentiles = c(0.025, 0.5, 0.975), plot = FALSE, show.output = FALSE)
rownames(mc_nodes_upper_average_actu_biomass_yield$marginal) <- paste0('upper_average_Actual_yield_', rownames(mc_nodes_upper_average_actu_biomass_yield$marginal))
mc_nodes_average_actu_biomass_yield <- list(mc_nodes_lower_average_actu_biomass_yield, mc_nodes_mid_average_actu_biomass_yield, mc_nodes_upper_average_actu_biomass_yield)


## associate average yield and the exploitable yield potential to their corresponding BNs nodes ####

tmp <- 1:length(Local_constraints_at_initial_stage_estimates)
names(tmp) <- names(Local_constraints_at_initial_stage_estimates)
est_int <- sapply(X=tmp, function(i){
  rbind (Local_constraints_at_initial_stage_estimates [[i]],
         mc_nodes_estimates_biomass_yield_pot, 
         mc_nodes_exploitable_biomass_yield_pot[[i]],
         mc_nodes_average_actu_biomass_yield[[i]]
  )
}, simplify = FALSE, USE.NAMES = TRUE)

## Biomass yield at dev stage #####

mc_nodes_biomass_exp_factor_dev <- estimate(distribution = 'gamma', lower = 0, median = 0.725, upper = 0.850, variable= 'biomass_exp_factor_dev', method = 'fit')

est_dev <- lapply(X=Local_constraints_at_development_stage_estimates, FUN = function(i){
  lapply(est_int, FUN = rbind,
         i,
         mc_nodes_biomass_exp_factor_dev)
})

## Biomass yield at mid stage #####

mc_nodes_biomass_exp_factor_mid <- estimate(distribution = 'gamma', lower = 0, median = 0.900, upper = 0.950, variable= 'biomass_exp_factor_mid', method = 'fit')

est_mid <- lapply(X=Local_constraints_at_mid_stage_estimates, FUN = function(i){
  lapply(est_dev, function(j) {
    lapply(j, function (k){
      rbind(k, i, mc_nodes_biomass_exp_factor_mid)
    })
  })
})

## Biomass yield at late stage #####

mc_nodes_biomass_exp_factor_late <- estimate(distribution = 'gamma', lower = 0, median = 0.975, upper = 1, variable= 'biomass_exp_factor_late', method = 'fit')
mc_nodes_harvest_index <- estimate(distribution = 'unif', lower = 0.1, median=0.2, upper = 0.3, variable= 'harvest_index', method = 'fit')
mc_nodes_biomass_exp_factor_init <- estimate(distribution = 'gamma', lower = 0, median = 0.090, upper = 0.100, variable= 'biomass_exp_factor_init', method = 'fit')

est_late <- lapply(X=Local_constraints_at_late_stage_estimates, FUN = function(i){
  lapply(est_mid, function(j) {
    lapply(j, function(k){
      lapply(k, function (l){
        rbind(l, i, 
              mc_nodes_biomass_exp_factor_late, 
              mc_nodes_harvest_index, 
              mc_nodes_biomass_exp_factor_init)
      })
    })
  })
})


## Running the MC similation ####

model_function <- function(x){
  # initial stage 
  attainable_yield_at_initial_stage <- x[,2] * x[, 6] 
  exploitable_yield_gap_at_initial_stage <- attainable_yield_at_initial_stage - x[,10]
  ##############################################################################################
  exploitable_yield_gap_at_initial_stage <- ifelse(exploitable_yield_gap_at_initial_stage < 0, 0, exploitable_yield_gap_at_initial_stage) # because average yield cannot go beyond attainable. 
  ##############################################################################################
  exploitable_yield_gap_loss_due_to_constraints_at_initial_stage <- exploitable_yield_gap_at_initial_stage * x[, 1]
    ##############################################################################################
  exploitable_yield_gap_loss_due_to_constraints_at_initial_stage <- ifelse(exploitable_yield_gap_loss_due_to_constraints_at_initial_stage <= exploitable_yield_gap_at_initial_stage, exploitable_yield_gap_loss_due_to_constraints_at_initial_stage, exploitable_yield_gap_at_initial_stage) # because exploitable_yield_gap_loss_due_to_constraints_at_initial_stage cannot exceed the exploitable_yield_gap_at_initial_stage itself.
    ##############################################################################################
  actually_exploited_yield_gap_at_initial_stage <- exploitable_yield_gap_at_initial_stage - exploitable_yield_gap_loss_due_to_constraints_at_initial_stage
  expected_actual_yield_at_initial_stage <- actually_exploited_yield_gap_at_initial_stage + x[, 10]
  
  ##############################################################################################
  expected_actual_yield_at_initial_stage <- ifelse(expected_actual_yield_at_initial_stage > attainable_yield_at_initial_stage, attainable_yield_at_initial_stage, expected_actual_yield_at_initial_stage) # becuase yield expectation cannot go beyond the attainable limit.
  ##############################################################################################
  
  initial_stage = list(
    # attainable_yield_at_initial_stage = attainable_yield_at_initial_stage,
    exploitable_yield_gap_at_initial_stage = exploitable_yield_gap_at_initial_stage,
    exploitable_yield_gap_loss_due_to_constraints_at_initial_stage = exploitable_yield_gap_loss_due_to_constraints_at_initial_stage,
    actually_exploited_yield_gap_at_initial_stage = actually_exploited_yield_gap_at_initial_stage,
    expected_actual_yield_at_initial_stage=expected_actual_yield_at_initial_stage)
  
  # dev stage
  exploitable_yield_gap_at_development_stage <- exploitable_yield_gap_at_initial_stage + (exploitable_yield_gap_at_initial_stage * x[,15])
  # exploitable_yield_gap_at_development_stage <- (exploitable_yield_gap_at_initial_stage * x[,15])/x[, 21]
  exploitable_yield_gap_loss_due_to_constraints_at_development_stage <- exploitable_yield_gap_at_development_stage * x[, 14]
      ##############################################################################################
  exploitable_yield_gap_loss_due_to_constraints_at_development_stage <- ifelse(exploitable_yield_gap_loss_due_to_constraints_at_development_stage <= exploitable_yield_gap_at_development_stage, exploitable_yield_gap_loss_due_to_constraints_at_development_stage, exploitable_yield_gap_at_development_stage) # because exploitable_yield_gap_loss_due_to_constraints_at_development_stage cannot exceed the exploitable_yield_gap_at_development_stage itself.
    ##############################################################################################
  actually_exploited_yield_gap_at_development_stage <- exploitable_yield_gap_at_development_stage - exploitable_yield_gap_loss_due_to_constraints_at_development_stage
  # expected_actual_yield_at_development_stage <- actually_exploited_yield_gap_at_development_stage + (expected_actual_yield_at_initial_stage * x[, 15])
    expected_actual_yield_at_development_stage <- actually_exploited_yield_gap_at_development_stage + (expected_actual_yield_at_initial_stage * x[, 15])

  dev_stage = list(exploitable_yield_gap_at_development_stage = exploitable_yield_gap_at_development_stage,
                   exploitable_yield_gap_loss_due_to_constraints_at_development_stage = exploitable_yield_gap_loss_due_to_constraints_at_development_stage,
                   actually_exploited_yield_gap_at_development_stage = actually_exploited_yield_gap_at_development_stage,
                   expected_actual_yield_at_development_stage = expected_actual_yield_at_development_stage)
  
  # mid stage
  exploitable_yield_gap_at_mid_stage <- exploitable_yield_gap_at_development_stage + exploitable_yield_gap_at_development_stage * x[,17]
  exploitable_yield_gap_loss_due_to_constraints_at_mid_stage <- exploitable_yield_gap_at_mid_stage * x[, 16]
  ##############################################################################################
  exploitable_yield_gap_loss_due_to_constraints_at_mid_stage <- ifelse(exploitable_yield_gap_loss_due_to_constraints_at_mid_stage <= exploitable_yield_gap_at_mid_stage, exploitable_yield_gap_loss_due_to_constraints_at_mid_stage, exploitable_yield_gap_at_mid_stage) # because exploitable_yield_gap_loss_due_to_constraints_at_mid_stage cannot exceed the exploitable_yield_gap_at_mid_stage itself.
    ##############################################################################################
  actually_exploited_yield_gap_at_mid_stage <- exploitable_yield_gap_at_mid_stage - exploitable_yield_gap_loss_due_to_constraints_at_mid_stage
  expected_actual_yield_at_mid_stage <-  actually_exploited_yield_gap_at_mid_stage + (expected_actual_yield_at_development_stage * x[, 17])
  
  mid_stage = list(exploitable_yield_gap_at_mid_stage = exploitable_yield_gap_at_mid_stage,
                   exploitable_yield_gap_loss_due_to_constraints_at_mid_stage = exploitable_yield_gap_loss_due_to_constraints_at_mid_stage,
                   actually_exploited_yield_gap_at_mid_stage = actually_exploited_yield_gap_at_mid_stage,
                   expected_actual_yield_at_mid_stage = expected_actual_yield_at_mid_stage)
  
  # late stage
  exploitable_yield_gap_at_late_stage <- exploitable_yield_gap_at_mid_stage + exploitable_yield_gap_at_mid_stage * x[,19]
  exploitable_yield_gap_loss_due_to_constraints_at_late_stage <- exploitable_yield_gap_at_late_stage * x[, 18]
   ##############################################################################################
  exploitable_yield_gap_loss_due_to_constraints_at_late_stage <- ifelse(exploitable_yield_gap_loss_due_to_constraints_at_late_stage <= exploitable_yield_gap_at_late_stage, exploitable_yield_gap_loss_due_to_constraints_at_late_stage, exploitable_yield_gap_at_late_stage) # because exploitable_yield_gap_loss_due_to_constraints_at_late_stage cannot exceed the exploitable_yield_gap_at_late_stage itself.
    ##############################################################################################
  actually_exploited_yield_gap_at_late_stage <- exploitable_yield_gap_at_late_stage - exploitable_yield_gap_loss_due_to_constraints_at_late_stage
  expected_actual_yield_at_late_stage <-  actually_exploited_yield_gap_at_late_stage + (expected_actual_yield_at_mid_stage * x[,19])
  
  late_stage = list(exploitable_yield_gap_at_late_stage = exploitable_yield_gap_at_late_stage,
                    exploitable_yield_gap_loss_due_to_constraints_at_late_stage = exploitable_yield_gap_loss_due_to_constraints_at_late_stage,
                    actually_exploited_yield_gap_at_late_stage = actually_exploited_yield_gap_at_late_stage,
                    expected_actual_yield_at_late_stage = expected_actual_yield_at_late_stage)
  
  # grain yield
  actually_exploited_yield_gap = actually_exploited_yield_gap_at_late_stage * x[, 20]
  exploitable_yield_gap = exploitable_yield_gap_at_late_stage * x[, 20]
  expected_actual_yield = expected_actual_yield_at_late_stage * x[, 20]
  exploitable_yield_gap_loss_due_to_constraints = exploitable_yield_gap_loss_due_to_constraints_at_mid_stage * x[, 20]
  
  grain_yield = list(exploitable_yield_gap = exploitable_yield_gap, 
                     exploitable_yield_gap_loss_due_to_constraints = exploitable_yield_gap_loss_due_to_constraints,
                     actually_exploited_yield_gap = actually_exploited_yield_gap,
                     expected_actual_yield = expected_actual_yield)
  
  
  ## Outputs
  out <- list(initial_stage = initial_stage, dev_stage = dev_stage, mid_stage = mid_stage, 
              late_stage = late_stage, grain_yield = grain_yield)
  return(out)
}


state_ids = 1:length(est_late)
names(state_ids) <- names(est_late)

ssp <- sapply(X=state_ids, function (i) {
  sapply(est_late[[i]], function (j){
    sapply(j, function(k){
      sapply(k, function(l){
        # mcSimulation(estimate = l, model_function = model_function, state_effects = state_effects [i], numberOfModelRuns=10000, functionSyntax="matrixNames")
        mcSimulation(estimate = l, model_function = model_function, numberOfModelRuns=10000, functionSyntax="matrixNames")
        
      }, simplify = FALSE, USE.NAMES = TRUE)
    }, simplify = FALSE, USE.NAMES = TRUE)
  }, simplify = FALSE, USE.NAMES = TRUE)
}, simplify = FALSE, USE.NAMES = TRUE)

saveRDS(ssp, paste0("output_files", "/", "Modelling_FBFS_model_RAW_predictions_Case_study_2.rds"))
```

```{r case study 2 Results:Biomass yield at Initial stage, include = FALSE, echo = FALSE, cache = FALSE}

ssp<- readRDS(paste0("output_files", "/", "Modelling_FBFS_model_RAW_predictions_Case_study_2.rds"))

## ggplotting the similations ####

## General settings for all plotting options ####

p = ggplot_mc_dens(ssp, 
                                      colorQuantile = c("red", "green", "green", "green", "green", "green", "red1"),

                   # colorQuantile = c("GRAY46", "lavender", "lavender", "lavender", "lavender", "lavender", "GRAY47"),
                                       colorProbability = c(1.00,    0.95,     0.75,     0.55,         0.45,     0.25,     0.05))

gg_data <- p$data

# saveRDS(gg_data, paste0("output_files", "/", "Modelling_FBFS_model_predictions_Case_study_2.rds"))

# y_scaleFUN <- function(x) sprintf("%.1f", x)
# x_scaleFUN <- function(x) sprintf("%.1f", x)

scale_fun <- function(gg_obj, new_data, split_column, facet_column) {
  if (!is.null(new_data)){
    p <- p %+% new_data
  } else {
    p <- gg_obj
  }
  sapply(unique(p$data[[split_column]]), function(i){
    # p$data[[facet_column]] <- factor(p$data[[facet_column]], levels = unique(p$data[[facet_column]]))
    p_data <- p$data[grepl(i, p$data[[split_column]]), ]
    data_list <- split(p_data, p_data[[facet_column]])
    my_fill <- lapply(data_list, function (x){
      scale_fill_identity(NULL, labels = x$color_equiv, breaks = x$color,
                          guide = 'none', drop = FALSE)
    })
    p_i = p %+% p_data +
      # scale_x_continuous(
      #   # labels = y_scaleFUN,
      #   breaks = function(x) breaksFUN (x)[-1],
      #   expand = c(0,0)
      # )+
      # scale_y_continuous(
      #   # labels = x_scaleFUN,
      #   breaks = breaksFUN,
      #   expand = c(0,0)
      # )+
      my_fill+
      my_theme +
      labs(subtitle = gsub("_", " ", gsub("initial_stage.|at_initial_stage|dev_stage.|at_development_stage|mid_stage.|at_mid_stage|late_stage.|at_late_stage|grain_yield.", "", i)))
    # p_i +     scale_x_continuous(
    #   # labels = x_scaleFUN, 
    #   expand = c(0,0)
    # )+
    #   scale_y_continuous(
    #     # labels = y_scaleFUN, 
    #     expand = c(0,0))
    p_i + theme(axis.title = element_blank(),
                axis.text = element_text(size = plot_font_size+2),
                plot.subtitle=element_text(size = plot_font_size+2, face="bold.italic", color='dimgrey'),
                strip.text.x = element_text(margin = margin(t=1, b = 1))
            )
  }, simplify = FALSE, USE.NAMES = TRUE)
}

# grid_fun <- function(gg_list) {
#   tmp <- 1:length(gg_list)
#   names(tmp) <- names(gg_list)
#   sapply(tmp, function(i){
#     if (i == 1){
#       gg_list[[i]] +
#         my_theme+
#         theme(
#           # strip.background = element_rect(fill='lightgoldenrodyellow'),
#           plot.title = element_blank(),
#           axis.title = element_blank(),
#           # plot.margin=unit(c(0, 0, 0, 0), "pt"),
#           # plot.margin=unit(c(2, 1, 1, 1), "pt"),
#           strip.text = element_text(colour = 'black'),
#           axis.text = element_text(size = plot_font_size+2),
#           strip.text.x = element_text(margin = margin(t=1, b = 1))
#         )
#     } else {
#       gg_list[[i]]+ guides(fill = FALSE)+
#         my_theme +
#         theme(
#           plot.title = element_blank(),
#           strip.text = element_blank(),
#           strip.background = element_blank(),
#           # plot.margin=unit(c(5, 1, 0, 0), "pt"),
#           # panel.border = element_rect(fill=NA, size = 0.05),
#           # panel.grid.major = element_line(size = 0.05),
#           # panel.grid.minor = element_line(size = 0.02),
#           axis.title = element_blank(),
#           axis.text = element_text(size = plot_font_size+2),
#           strip.text.x = element_text(margin = margin(t=1, b = 1)),
#           )
#     }
#   }, simplify = FALSE, USE.NAMES = TRUE)
# }

# limits_fun <- function(gg_list, facet_column){
#   sapply(gg_list, function(i){
#     gg_data <- i$data
#     ids <- unique(gg_data[[facet_column]])
#     names(ids) <- ids
#     sapply(ids, function(j){
#       tmp <- gg_data[gg_data[[facet_column]] == j, 'y']
#       range(tmp)
#     })
#   }, simplify = F)
# }
## Biomass yield at initial stage ####
dat <- gg_data[grepl("initial_stage.", gg_data$L5), ]
dat$L5 <- factor(dat$L5, levels = unique(dat$L5))
dat <- split(dat, dat$L5)
tmp <- 1:length(dat)
names(tmp) <- names(dat)
# min_y <- c(0.003, 0.04, 0.003, 0.003)
# dat <- sapply(tmp, function(i){
#   dat[[i]] [dat[[i]]$y > min_y[i], ]
# }, simplify = FALSE, USE.NAMES = TRUE)
dat <- do.call(rbind, dat)

dat$L4 <- factor(dat$L4, levels = unique(dat$L4))
# p1 <- grid_fun(scale_fun(gg_obj = p, new_data = dat, split_column = 'L5', facet_column = 'L4'))
p1 <- scale_fun(gg_obj = p, new_data = dat, split_column = 'L5', facet_column = 'L4')

labeller0 <- unique(gg_data$L4)
labeller1 <- gsub(pattern = 'at_initial_stage', replacement = '', labeller0)
labeller1 <- gsub(pattern = 'Local', replacement = 'Farming', labeller1)
labeller1 <- gsub(pattern = '_', replacement = ' ', labeller1)
labeller1 <- gsub(pattern = '=', replacement = ' = ', labeller1)
names(labeller1) <- labeller0


## facet_wrap with ribbon ####

# # x_limits <- list(c(-0.50, 4.00), 
# #                  c(-0.10, 7.50), 
# #                  c(-0.50, 3.00),
# #                  c(-0.75, 3.00))
# x_limits <- list(function(x) c(min(x, na.rm = TRUE), 3.0),
#                  function(x) c(min(x, na.rm = TRUE), 6),
#                  function(x) c(min(x, na.rm = TRUE), 3.0),
#                  function(x) c(min(x, na.rm = TRUE), 3.0))
# 
# x_breaks <- list(seq(0.00, 10.00, by=2.00),
#                  seq(0.00, 6, by=2),
#                  seq(0.00, 10.00, by=2.00),
#                  seq(0.00, 10.00, by=2.00))
# 
# y_breaks <- list(seq(0.00, 1.25, by=0.62),
#                  seq(0.00, 35, by=17.5),
#                  seq(0.00, 2.50, by=1.25),
#                  seq(0.00, 2.25, by=1.12))

x_breaks <- list(function (x) seq(0.00, max(x, na.rm = TRUE), by=2.00),
                 function (x) seq(0.00, max(x, na.rm = TRUE), by=2.00),
                 function (x) seq(0.00, max(x, na.rm = TRUE), by=2.00),
                 function (x) seq(0.00, max(x, na.rm = TRUE), by=2.00))

y_breaks <- list(function (x) seq(0.00, max(x, na.rm = TRUE), by=0.62),
                 function (x) seq(0.00, max(x, na.rm = TRUE), by=17.5),
                 function (x) seq(0.00, max(x, na.rm = TRUE), by=1.25),
                 function (x) seq(0.00, max(x, na.rm = TRUE), by=1.12))

tmp <- 1:length(p1)
names(tmp) <- names(p1)
p1 <- sapply(X = tmp, function(i) {
  p_i <- p1[[i]] +
    aes(x, y, fill = color, color = color)+
    scale_fill_identity(NULL, labels = p1[[1]]$data$color_equiv,
                        breaks = p1[[1]]$data$color, guide = "legend", drop = FALSE)+
    scale_color_identity(NULL, labels = p1[[1]]$data$color_equiv,
                         breaks = p1[[1]]$data$color, guide = "legend", drop = FALSE)+
    facet_wrap(.~L4, nrow= 1, labeller = as_labeller(labeller1))+
    scale_x_continuous(breaks = x_breaks[[i]])+
    scale_y_continuous(breaks = y_breaks[[i]]) +
    theme(legend.position = "none",
          plot.margin=unit(c(1, 2.5, 1, 1), "pt"))
  if(i == 1){
      p_i <- p_i + theme(strip.text = element_text(size = plot_font_size+1,  face = 'bold'))
  } else {
    p_i <- p_i + theme(strip.text = element_blank())
  }
  return(p_i)
}, simplify = FALSE, USE.NAMES = T)

p1$ncol=1

# p1$top = grid::textGrob("The green and red colors, respectively, are values inside and outside the 90% confidence interval. In x-axis
# are simulated yield values in t/ha and y-axis represent their density. FC stands for farming constraint and
# the indices i, ii, iiii, respectively,represent crop at initial, developement and late stages.",
#                         # x=1, y=0, hjust=0.5, vjust=0.5,
#                         x=1, hjust=0, vjust = 0.5,
#                         # x=1, hjust=1, vjust = 1,
#                         gp = gpar(fontfamily=plots_font_family,fontsize=plot_font_size,fontface="italic", col="black"))

# p1$left = grid::textGrob("Density", rot = 90,  
#                          gp = gpar(fontfamily=plots_font_family,fontsize=plot_font_size, col="black"))

p1$bottom <-  grid::textGrob("Biomass yield at initial stage of crop development", 
                             gp = gpar(fontfamily=plots_font_family,fontsize=plot_font_size+2,  col="black"))

grid.newpage()
ga = do.call("grid.arrange", p1)
gb = grid.rect(.5,.5,width=unit(1,"npc"), height=unit(1,"npc"), 
               gp=gpar(lwd=1, fill=NA, col="lightgray"))
g1 <- gTree(children = gList(ga, gb))
ggsave(plot=g1, device = 'png', filename = "figures/Modelling_FBFS_biomass_yield_initial_stage.png", width = max_plots_width_in, 
       height =max_plots_height_in/2.25, units = "in", dpi = min_plots_res)
```

```{r case study 2 Results:Biomass yield at Late stage, include = FALSE, echo = FALSE, cache = FALSE}

## Biomass yield at Late stage ####
dat <- gg_data[grepl("late_stage.", gg_data$L5), ]
dat$L5 <- factor(dat$L5, levels = unique(dat$L5))

dat$facet_query <- paste(dat$L1, " / ",  dat$L2, " /\n", dat$L3, " / ", dat$L4, sep = '')
dat$facet_query <- gsub(pattern = 'Local_constraints_', replacement = "{bold('FC'", dat$facet_query)
dat$facet_query <- gsub(pattern = 'at_late_stage', replacement = "[italic(iiii)]", dat$facet_query)

dat$facet_query <- gsub(pattern = 'at_mid_stage', replacement = "[italic(iii)]", dat$facet_query)
dat$facet_query <- gsub(pattern = 'at_development_stage', replacement = "[italic(ii)]", dat$facet_query)
dat$facet_query <- gsub(pattern = 'at_initial_stage', replacement = "[italic(i)]", dat$facet_query)
dat$facet_query <- gsub(pattern = '=', replacement = "==", dat$facet_query)

dat$facet_query <- gsub(pattern = 'Low', replacement = "L", dat$facet_query)
dat$facet_query <- gsub(pattern = 'Medium', replacement = "M", dat$facet_query)
dat$facet_query <- gsub(pattern = 'High', replacement = "H", dat$facet_query)

dat$facet_query <- gsub(pattern = '/', replacement = ")} / ", dat$facet_query)
dat$facet_query <- paste0(dat$facet_query, ")}")

cond <- (dat$L1 == "Local_constraints_at_late_stage=High" & dat$L2 == "Local_constraints_at_mid_stage=High" & dat$L3 == "Local_constraints_at_development_stage=High" & dat$L4 == "Local_constraints_at_initial_stage=High")|
  (dat$L1 == "Local_constraints_at_late_stage=Medium" & dat$L2 == "Local_constraints_at_mid_stage=Medium" & dat$L3 == "Local_constraints_at_development_stage=Medium" & dat$L4 == "Local_constraints_at_initial_stage=Medium")|
  (dat$L1 == "Local_constraints_at_late_stage=Low" & dat$L2 == "Local_constraints_at_mid_stage=Low" & dat$L3 == "Local_constraints_at_development_stage=Low" & dat$L4 == "Local_constraints_at_initial_stage=Low")

dat <- dat[cond, ]

dat$facet_query <- factor(dat$facet_query, levels = unique(dat$facet_query)[c(3, 1, 2)])

dat <- split(dat, dat$L5)
tmp <- 1:length(dat)
names(tmp) <- names(dat)
# min_y <- c(0.00095, 0.015, 0.001, 0.0005)
# 
# # min_y <- c(0.001, 0.01, 0.001, 0.001)
# dat <- sapply(tmp, function(i){
#   dat[[i]] [dat[[i]]$y > min_y[i], ]
# }, simplify = FALSE, USE.NAMES = TRUE)
dat <- do.call(rbind, dat)

## facet_wrap with ribbon ####

# # x_limits <- list(c(-2.50, 20.00),
# #                  c(-0.50, 15.00),
# #                  c(-2.00, 20.00),
# #                  c(-3.00, 30.00))
# x_limits <- list(function(x) c(min(x, na.rm = TRUE), 20),
#                  function(x) c(min(x, na.rm = TRUE), 15),
#                  function(x) c(min(x, na.rm = TRUE), 20),
#                  function(x) c(min(x, na.rm = TRUE), 30))
# 
# 
x_breaks <- list(function (x) seq(0.00, max(x, na.rm = TRUE), by=10.00),
                 function (x) seq(0.00, max(x, na.rm = TRUE), by=10.00),
                 function (x) seq(0.00, max(x, na.rm = TRUE), by=10.00),
                 function (x) seq(0.00, max(x, na.rm = TRUE), by=20.00))

y_breaks <- list(function (x) seq(0.00, max(x, na.rm = TRUE), by=0.09),
                 function (x) seq(0.00, max(x, na.rm = TRUE), by=2.55),
                 function (x) seq(0.00, max(x, na.rm = TRUE), by=0.19),
                 function (x) seq(0.00, max(x, na.rm = TRUE), by=0.07))

p1 <- scale_fun(gg_obj = p, new_data = dat, split_column = 'L5', facet_column = 'facet_query')

tmp <- 1:length(p1)
names(tmp) <- names(p1)
# p1 <- sapply(X = tmp, function(i) {
#   p_i = p1[[i]] + 
#     # geom_line(aes(y = y))+
#     # geom_ribbon(aes(ymin = 0, ymax = y, fill = color), alpha = 0.5) +
#     aes(x, y, fill = color, color = color)+
#     scale_fill_identity(NULL, labels = p1[[1]]$data$color_equiv, 
#                         breaks = p1[[1]]$data$color, guide = "legend", drop = FALSE)+
#     scale_color_identity(NULL, labels = p1[[1]]$data$color_equiv, 
#                          breaks = p1[[1]]$data$color, guide = "legend", drop = FALSE)+
#     facet_wrap(.~facet_query, nrow= 1, labeller = label_parsed)+
#     # scale_x_continuous(breaks = x_breaks[[i]], limits = x_limits[[i]], labels = x_scaleFUN)+
#     # scale_y_continuous(labels = y_scaleFUN)+
#         theme(legend.position = "none")
#   if (i==1){
#     p_i = p_i +
#       theme(strip.text = element_text(size = 6))
#     # + scale_y_continuous(breaks = c(0.00, 0.15))
#   }
#   p_i + scale_x_continuous(breaks = x_breaks[[i]])+
#     scale_y_continuous(breaks = y_breaks[[i]])+
#     theme(plot.margin=unit(c(1, 1, 1, 1), "pt"))
# }, simplify = FALSE, USE.NAMES = T)

p1 <- sapply(X = tmp, function(i) {
  p_i <- p1[[i]] +
    aes(x, y, fill = color, color = color)+
    scale_fill_identity(NULL, labels = p1[[1]]$data$color_equiv,
                        breaks = p1[[1]]$data$color, guide = "legend", drop = FALSE)+
    scale_color_identity(NULL, labels = p1[[1]]$data$color_equiv,
                         breaks = p1[[1]]$data$color, guide = "legend", drop = FALSE)+
    facet_wrap(.~facet_query, nrow= 1, labeller = label_parsed)+
    scale_x_continuous(breaks = x_breaks[[i]])+
    scale_y_continuous(breaks = y_breaks[[i]]) +
    theme(legend.position = "none",
          plot.margin=unit(c(1, 2.5, 1, 1), "pt"))
    if(i == 1){
      p_i <- p_i + theme(strip.text = element_text(size = plot_font_size-1,  face = 'bold'))
    } else {
    p_i <- p_i + theme(strip.text = element_blank())
  }
  return(p_i)
}, simplify = FALSE, USE.NAMES = T)

p1$ncol=1

# p1$top = grid::textGrob("The blue and grey colors, respectively, are values inside and outside the 90% confidence interval. Values on x-axis are in t/ha.",
#                         x=1, y = 0, hjust=1, vjust= 1,
#                         gp = gpar(fontfamily=plots_font_family, fontsize=plot_font_size-3, fontface = "italic", col="black"))

# p1$left = grid::textGrob("Density", rot = 90,
#                          gp = gpar(fontfamily=plots_font_family,fontsize=plot_font_size,  col="black"))

p1$bottom <-  grid::textGrob("Biomass yield at late stage of crop development",
                             gp = gpar(fontfamily=plots_font_family,fontsize=plot_font_size+2,  col="black"))

grid.newpage()
ga = do.call("grid.arrange", p1)
gb = grid.rect(.5,.5,width=unit(1,"npc"), height=unit(1,"npc"), 
               gp=gpar(lwd=1, fill=NA, col="lightgray"))
g2 <- gTree(children = gList(ga, gb))

ggsave(plot=g2, device = 'png', filename = "figures/Modelling_FBFS_biomass_yield_late_stage.png", width = max_plots_width_in, 
       height =max_plots_height_in/2.5, units = "in", dpi = min_plots_res)
```

```{r case study 2 Results:Biomass yield, include = FALSE, echo = FALSE, cache = FALSE}

g <- list(g1,g2)

g$ncol=1

g$top = grid::textGrob("The green and red colors, respectively, are values inside and outside the 90% confidence interval. In x-axis are simulated yield values
in t/ha and y-axis represent their density. FC = farming constraint, H = High, M = Medium, L = Low. The indices i, ii, iii, iiii,
respectively, indicate crop at initial, developement, mid and late stages.",
                        # x=1, y=0, hjust=0.5, vjust=0.5,
                        # x=1, hjust=0, vjust = 0.5,
                        # x=1, hjust=1, vjust = 1,
                        x=0, hjust=0, vjust = 0.5,
                        gp = gpar(fontfamily=plots_font_family,fontsize=plot_font_size,fontface="italic", col="black"))

grid.newpage()
ga = do.call("grid.arrange", g)
gb = grid.rect(.5,.5,width=unit(1,"npc"), height=unit(1,"npc"), 
               gp=gpar(lwd=1, fill=NA, col="lightgray"))
g1 <- gTree(children = gList(ga, gb))

ggsave(plot=g1, device = 'png', filename = "figures/Modelling_FBFS_biomass_yield_Initial_and_late_stage.png", width = max_plots_width_in,
       height =2*max_plots_height_in/2.25, units = "in", dpi = min_plots_res
)
```

```{r fig8,echo=FALSE,fig.width=max_plots_width_in,fig.height=2*max_plots_height_in/2.25,dpi=min_plots_res,fig.cap="Simulated biomass yield metrics in FBFS in Kisumu (Kenya) and Tigray (Ethiopia)."}

# g <- grid.arrange(g1,g2)
g <- grid.arrange(g1)
# ggsave(plot=g, device = 'png', filename = "figures/Modelling_FBFS_biomass_yield_Initial_and_late_stage.png", width = max_plots_width_in, 
#        height =2*max_plots_height_in/2.25, units = "in", dpi = min_plots_res
# )
```

### Quantitative grain yield variability and relative performance of Rice and Sorghum under constraint at mid-stage of crop development in flood-based Agriculture. {#IV23}

#### Introduction {#IV231}

Many important risk factors for farmers (e.g. pest and diseases, weeds) are often overlooked by crop models because they are either difficult to measure or too complex to include. The stochastic nature of such factors makes them difficult to predict with accuracy. The impact of pest and disease or weeds on crop yield becomes even more important in FBFS due to their hydrology. Depending on the spacing, some crops may require more of the farmer’s skill in the matter than others.  For example, weed removal in teff can be difficult and time consuming compared to sorghum which is traditionally planted in relatively sparse rows. Weed seeds may be carried in by the flood water which further creates suitable conditions for their germination and growth. In most FBFS, therefore, farmers must protect their crops at every stage against a host of biotic stressors. This becomes challenging when the available labour force is limited, in which case the farmer must prioritize certain crop protection activities over other. Such prioritization should be based on comparative analysis of plausible outcomes for different scenarios. The objective of this short case study is to demonstrate how the model can be customized for use in relative assessments of the impact of such aspects on crop yield. As in the first case study, we formulated different evidence-based specifications to query the model and study the effect of pests, diseases and weeds, and the available soil water on grain yield of rice and sorghum. Assessment were provided relative to the corresponding rainfed agriculture in the areas.

#### Materials and Methods {#IV232}

To assess the effect of pests, diseases, weeds, the available soil water and crop type on grain yield, we queried the model based on these variables and simulate, for each query, the grain yield of rice and sorghum under FBFS settings in Kisumu county of Kenya and Tigray region in Ethiopia. Each query was run 1000 times as in the `mcSimulation` function [@Luedeling_and_Goehring_2018].  For each of the 4 treatments, we selected the 2 extremes states of the corresponding node in BNs to derive a sequence of all possible combinations. These were then used as evidence to query the posterior distribution of the node farming constraint in the BNs. Scenarios were assumed at the mid stage of crop development. The results of the BN queries were used to provide customized estimates of the node farming constraints to the MC model as described in section \@ref(III32) The simulated grain yield data were then analysed accounting for uncertainty in estimates.

```{r case study 3 methods rds 1, eval=TRUE,include=FALSE, echo=FALSE,cache=FALSE}

##Farming constraints partial  ####

net <- bnlearn::model2network("[Available_soil_nutrients_at_mid_stage][Available_soil_water_at_mid_stage][Effectiveness_of_Weeding_at_mid_stage][Weeds_impact_at_development_stage][Crop_type][Effectiveness_of_pest_and_disease_reduction_practices_at_mid_stage][Pest_and_desease_impact_at_development_stage][Weeds_impact_at_mid_stage|Effectiveness_of_Weeding_at_mid_stage:Weeds_impact_at_development_stage:Crop_type][Pest_and_desease_impact_at_mid_stage|Effectiveness_of_pest_and_disease_reduction_practices_at_mid_stage:Pest_and_desease_impact_at_development_stage:Crop_type][Agricultural_management_efficiency_at_mid_stage|nutrient_supply_adequacy_at_mid_stage:Pest_and_desease_impact_at_mid_stage:Weeds_impact_at_mid_stage][nutrient_supply_adequacy_at_mid_stage|Available_soil_nutrients_at_mid_stage:Crop_type][Water_supply_adequacy_at_mid_stage|Available_soil_water_at_mid_stage:Crop_type][Effectiveness_of_cropping_options|Crop_type][Local_constraints_at_mid_stage|Effectiveness_of_cropping_options:Water_supply_adequacy_at_mid_stage:Agricultural_management_efficiency_at_mid_stage][Local_constraints_at_late_stage|Effectiveness_of_cropping_options:Water_supply_adequacy_at_mid_stage:Agricultural_management_efficiency_at_mid_stage]")

net <- decisionSupportExtra::extract_bn(bn = network_bn_fit, string_model = net)
saveRDS(net, paste0("output_files", "/", "Modelling_FBFS_BNs_Case_study_3.rds"))
rm(network_bn_fit); gc(verbose=FALSE)
```

```{r case study 3 methods plot, include = FALSE, echo = FALSE, cache = FALSE}

net <- readRDS("output_files/Modelling_FBFS_BNs_Case_study_3.rds")

legende = c(AgricManagEff = "Agricultural_management_efficiency_at_mid_stage", 
            AvailSoilNut = "Available_soil_nutrients_at_mid_stage", 
            AvailSoilWater = "Available_soil_water_at_mid_stage",
            CropType = "Crop_type",
            EffCropOptions = "Effectiveness_of_cropping_options", 
            EffPestDiseaseReduc = "Effectiveness_of_pest_and_disease_reduction_practices_at_mid_stage", 
            EffWeeding = "Effectiveness_of_Weeding_at_mid_stage", 
            FarmConstraintsLate = "Local_constraints_at_late_stage",
            FarmConstraints = "Local_constraints_at_mid_stage", 
            AdeqNutSupl = "nutrient_supply_adequacy_at_mid_stage",
            PestDeseaseImpactDev = "Pest_and_desease_impact_at_development_stage",
            PestDeseaseImpact = "Pest_and_desease_impact_at_mid_stage", 
            AdeqWatSupl = "Water_supply_adequacy_at_mid_stage", 
            WeedsImpactDev = "Weeds_impact_at_development_stage", 
            WeedsImpact = "Weeds_impact_at_mid_stage"
)

legende <- mapply(paste, names(legende), sprintf('\u2192'), legende)
legende <- gsub("_", " ",  legende)
legende <- gsub(" at mid stage", "",  legende)

bnlearn::nodes(net) <- names(legende)

png(export_fun(export = "Modelling_FBFS_Farming_Constraints"),
    res = min_plots_res,
    units = 'in',
    width = max_plots_width_in, 
    height = max_plots_height_in/2,
    pointsize = 10.5)
par(font=plots_font, family = plots_font_family, lwd=plots_lwd)

graphviz_chart_bn (x = net, type = "barprob", layout = "dot", draw.levels = TRUE,abbreviate=FALSE,
                   grid = TRUE, scale = c(max_plots_height_in/2, max_plots_width_in), col = "black", bg = "transparent",
                   text.col = "black", bar.col = "green", strip.bg = "lightyellow")
legend('bottomleft', legend = legende, text.width = 0.59*strwidth(legende[which.max(nchar(legende))]), 
       cex=0.59, ncol = 1,
       bty="o", box.lwd=1, box.col='lightyellow', xjust=1, yjust=1, bg=legend_bg,
       title = 'Legend', title.col = 'blue', inset=c(0.04, 0.08))
box(col = 'lightgray')
dev.off()
```

```{tikz fig10, echo=FALSE, fig.cap = "Overview of causality defining the Farming constraints in FBFS in Kisumu (Kenya) and Tigray (Ethiopia).", fig.ext = 'png', cache=FALSE, eval=TRUE, engine.opts = list(engine='xetex', template = "latex/tikz2pdf.tex")}
%% Beginning of Farming Constraints BNs %%%%

\begin{tikzpicture} [node distance = 2cm]
%%%%

\node[BnsBarplotStyle] (EffPestDiseaseReduc2)  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Poor,Good,Excellent}
                  ]

\addplot [AddPlotStyle]  coordinates { (0.162,Poor)(0.217,Good)     (0.621,Excellent)};

\end{axis}
\end{tikzpicture}
};
\tcbsetmacrotowidthofnode{\mywidth}{EffPestDiseaseReduc2}
\node[BnsBarplotTitleStyle, minimum width=\mywidth, align=center](EffPestDiseaseReduc1)[above=0pt of EffPestDiseaseReduc2]{Effectiveness of pest and disease\\ reduction practices};
%%%%


%%%%

\node[BnsBarplotStyle] (PestDiseaseImpact2) [below=of EffPestDiseaseReduc2]  {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Severe,Significant,Minor}
                  ]

\addplot [AddPlotStyle]  coordinates { (0.213,Severe)(0.190,Significant)(0.597,Minor)};

\end{axis}
\end{tikzpicture}
};
\tcbsetmacrotowidthofnode{\mywidth}{PestDiseaseImpact2}
\node[BnsBarplotTitleStyle, minimum width=\mywidth](PestDiseaseImpact1)[above=0pt of PestDiseaseImpact2]{Pest and disease impact};
%%%%


%%%%

\node[BnsBarplotStyle] (PestDiseaseImpactDev2) [below=of PestDiseaseImpact2] {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Severe,Significant,Minor}
                  ]

\addplot [AddPlotStyle]  coordinates { (0.213,Severe)(0.190,Significant)(0.597,Minor)};

\end{axis}
\end{tikzpicture}
};
\tcbsetmacrotowidthofnode{\mywidth}{PestDiseaseImpactDev2}
\node[BnsBarplotTitleStyle, minimum width=\mywidth, align=center](PestDiseaseImpactDev1)[above=0pt of PestDiseaseImpactDev2]{Pest and disease impact\\ at development stage};
%%%%

%%%%

\node[BnsBarplotStyle] (AgricManagEff2) [right=of PestDiseaseImpact2] {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Low,Medium,High}
                  ]

\addplot [AddPlotStyle]  coordinates { (0.276,Low)(0.268,Medium)(0.456,High)};

\end{axis}
\end{tikzpicture}
};
\tcbsetmacrotowidthofnode{\mywidth}{AgricManagEff2}
\node[BnsBarplotTitleStyle, minimum width=\mywidth, align=center](AgricManagEff1)[above=0pt of AgricManagEff2]{Agricultural management\\efficiency};
%%%%

%%%%

\node[BnsBarplotStyle] (AvailSoilNut2) [above=of AgricManagEff2] {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Deficient,Satisfactory,Plenty}
                  ]

\addplot [AddPlotStyle]  coordinates { (0.298,Deficient)(0.342,Satisfactory)(0.456,Plenty)};

\end{axis}
\end{tikzpicture}
};
\tcbsetmacrotowidthofnode{\mywidth}{AvailSoilNut2}
\node[BnsBarplotTitleStyle, minimum width=\mywidth](AvailSoilNut1)[above=0pt of AvailSoilNut2]{Available soil nutrients};
%%%%

%%%%
 
\node[BnsBarplotStyle] (WeedsImpact2)  [right=of AgricManagEff2]{
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Consuming,Moderate,Negligible}
                  ]

\addplot [AddPlotStyle]  coordinates { (0.359,Consuming)(0.126,Moderate)(0.515,Negligible)};

\end{axis}
\end{tikzpicture}
};
\tcbsetmacrotowidthofnode{\mywidth}{WeedsImpact2}
\node[BnsBarplotTitleStyle, minimum width=\mywidth](WeedsImpact1)[above=0pt of WeedsImpact2]{Weed impact};
%%%%


%%%%
 
\node[BnsBarplotStyle] (WeedsImpactDev2)  [below=of WeedsImpact2]{
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Consuming,Moderate,Negligible}
                  ]

\addplot [AddPlotStyle]  coordinates { (0.359,Consuming)(0.126,Moderate)(0.515,Negligible)};

\end{axis}
\end{tikzpicture}
};
\tcbsetmacrotowidthofnode{\mywidth}{WeedsImpactDev2}
\node[BnsBarplotTitleStyle, minimum width=\mywidth](WeedsImpactDev1)[above=0pt of WeedsImpactDev2]{Weed impact at development stage};
%%%%

%%%%
 
\node[BnsBarplotStyle] (EffWeeding2)  [above=of WeedsImpact1]{
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Poor,Good,Excellent}
                  ]

\addplot [AddPlotStyle]  coordinates { (0.204,Poor)(0.298,Good)(0.498,Excellent)};

\end{axis}
\end{tikzpicture}
};
\tcbsetmacrotowidthofnode{\mywidth}{EffWeeding2}
\node[BnsBarplotTitleStyle, minimum width=\mywidth](EffWeeding1)[above=0pt of EffWeeding2]{Effectiveness of Weeding};
%%%%

%%%%
 
\node[BnsBarplotStyle] (EffCropOptions2)  [below=of PestDiseaseImpactDev2]{
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Inefficient,Efficient}
                  ]

\addplot [AddPlotStyle]  coordinates { (0.511,Inefficient)(0.489,Efficient)};

\end{axis}
\end{tikzpicture}
};
\tcbsetmacrotowidthofnode{\mywidth}{EffCropOptions2}
\node[BnsBarplotTitleStyle, minimum width=\mywidth](EffCropOptions1)[above=0pt of EffCropOptions2]{Effectiveness of cropping options};

%%%%

\node[BnsBarplotStyle] (CropType2)  [below=of EffCropOptions2]{
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Sorghum,Maize,Teff,Rice}
                  ]

\addplot [AddPlotStyle]  coordinates { (0.300,Sorghum)(0.400,Maize)(0.100,Teff)(0.200,Rice) };

\end{axis}
\end{tikzpicture}
};
\tcbsetmacrotowidthofnode{\mywidth}{CropType2}
\node[BnsBarplotTitleStyle, minimum width=\mywidth](CropType1)[above=0pt of CropType2]{Crop type};
%%%%

%%%%

\node[BnsBarplotStyle] (FarmConstraints2) [right=of EffCropOptions2] {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {High,Medium,Low}
                  ]

\addplot [AddPlotStyle]  coordinates { (0.194,High)(0.466,Medium)(0.340,Low)};

\end{axis}
\end{tikzpicture}
};
\tcbsetmacrotowidthofnode{\mywidth}{FarmConstraints2}
\node[BnsBarplotTitleStyle, minimum width=\mywidth](FarmConstraints1)[above=0pt of FarmConstraints2]{Farming constraints};
%%%%

%%%%

\node[BnsBarplotStyle] (AdeqWatSupl2) [below=of FarmConstraints2] {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Inadequate,Adequate}
                  ]

\addplot [AddPlotStyle]  coordinates { (0.481,Inadequate)(0.519,Adequate)};

\end{axis}
\end{tikzpicture}
};
\tcbsetmacrotowidthofnode{\mywidth}{AdeqWatSupl2}
\node[BnsBarplotTitleStyle, minimum width=\mywidth](AdeqWatSupl1)[above=0pt of AdeqWatSupl2]{Water supply adequacy};
%%%%


\draw[thickarrow] (WeedsImpactDev1) --  (WeedsImpact2);
\draw[thickarrow] (EffWeeding2) --  (WeedsImpact1);

\draw[thickarrow] (PestDiseaseImpactDev1) --  (PestDiseaseImpact2);
\draw[thickarrow] (EffPestDiseaseReduc2) --  (PestDiseaseImpact1);

%\draw[thickarrow] (CropType1.north west) --  (WeedsImpact2.south east);
\draw[thickes] (CropType2.south) --  ([xshift=5mm,yshift=-5mm]CropType2.south);
\draw[thickes] ([xshift=5mm,yshift=-5mm]CropType2.south) -- ([yshift=-5mm, xshift=20mm]CropType2.south-|WeedsImpact2.south east);
\draw[thickes] ([yshift=-5mm, xshift=20mm]CropType2.south-|WeedsImpact2.south east)-- ([xshift=20mm]WeedsImpact2.east);
\draw[thickarrow] ([xshift=20mm]WeedsImpact2.east) -- (WeedsImpact2.east);

\draw[thickarrow] (CropType1) --  (EffCropOptions2);
\draw[thickarrow] (CropType2) --  (AdeqWatSupl2);
\draw[thickes] (CropType2.south) --  ([xshift=-5mm,yshift=-5mm]CropType2.south);
\draw[thickes] ([xshift=-5mm,yshift=-5mm]CropType2.south) -- ([yshift=-5mm, xshift=-5mm]CropType2.south-|PestDiseaseImpact2.south west);

\draw[thickes] ([yshift=-5mm, xshift=-5mm]CropType2.south-|PestDiseaseImpact2.south west) -- ([xshift=-5mm]PestDiseaseImpact2.west);
\draw[thickarrow]([xshift=-5mm]PestDiseaseImpact2.west) -- (PestDiseaseImpact2.west);

%\draw[thickarrow, name path= EffCropOptions2 -- FarmConstraints2] (EffCropOptions2) --  (FarmConstraints2);
\draw[thickarrow] (AdeqWatSupl1) --  (FarmConstraints2);
\draw[thickarrow] (AgricManagEff2) --  (FarmConstraints1);


\draw[thickarrow] (AvailSoilNut2) --  (AgricManagEff1);
\draw[thickarrow] (WeedsImpact2) --  (AgricManagEff2);
\draw[thickarrow] (PestDiseaseImpact2) --  (AgricManagEff2);

\node[draw=none, fill=none](FakeNode1) at ($(EffCropOptions1.north east)!0.4!(FarmConstraints1.north west)$) {};

%%%%

\node[BnsBarplotStyle] (AvailSoilWater2) [right=of AdeqWatSupl2] {
\nodepart{two}
\begin{tikzpicture}[use background]
\begin{axis}[AxisStyle,
                    symbolic y coords = {Drought risk,Normal, Waterlogging risk}
                  ]

\addplot [AddPlotStyle]  coordinates { (0.077,Drought risk)(0.292,Normal)(0.631,Waterlogging risk)};

\end{axis}
\end{tikzpicture}
};
\tcbsetmacrotowidthofnode{\mywidth}{AvailSoilWater2}
\node[BnsBarplotTitleStyle, minimum width=\mywidth](AvailSoilWater1)[above=0pt of AvailSoilWater2]{Available soil water};
%%%%

% \node[draw=none, fill=none] (FakeNode2) at (AvailSoilWater2.south|-AdeqWatSupl1.west) {};
%\draw[thickes, name path=AvailSoilWater2.south -- FakeNode2] (AvailSoilWater2.south) --  (FakeNode2.center);
% \draw[thickarrow] (FakeNode2.center) -- (AdeqWatSupl1.west);


%\path [name intersections={of=AvailSoilWater2.south -- FakeNode2 and EffCropOptions2 -- FarmConstraints2, by={A}}];

% \node[rectangle, draw=white, fill=white] at (A) { };
\draw[thickarrow] (AvailSoilWater2) --  (AdeqWatSupl2);
\draw[thickarrow] (EffCropOptions2) --  (FarmConstraints2);

\node[draw=none, fill=none](Topcheckpoint)[above=0.5cm of EffWeeding1]{};
\node[draw=none, fill=none](Leftcheckpoint)[left=0.75cm of CropType2]{};
\node[draw=none, fill=none](Bottomcheckpoint)[below=0.5cm of CropType2]{};
\node[draw=none, fill=none](Rightcheckpoint)[right=0.5cm of AvailSoilWater2]{};

\draw [ultra thick, lightgray](current bounding box.north west) rectangle (current bounding box.south east);

%% The following are repeated for visibility only 
%%\draw[thickes] (CropType2.south) --  ([yshift=-5mm]CropType2.south);
%%\draw[thickes] ([yshift=-5mm]CropType2.south) -- ([yshift=-5mm, xshift=-5mm]CropType2.south-|PestDiseaseImpact2.south west);

%%\draw[thickes] ([yshift=-5mm, xshift=-5mm]CropType2.south-|PestDiseaseImpact2.south west) -- ([xshift=-5mm]PestDiseaseImpact2.west);
%%\draw[thickarrow]([xshift=-5mm]PestDiseaseImpact2.west) -- (PestDiseaseImpact2.west);

%%\draw[thickes] (AgricManagEff1.north) -- ([yshift=5mm]EffWeeding1.north west-|AgricManagEff1.north);
%%\draw[thickes] ([yshift=5mm]EffWeeding1.north west-|AgricManagEff1.north) -- ([yshift=5mm]EffWeeding1.north west-|AgricManagEff1.north-|FarmConstraints1.north);
%%\draw[thickarrow] ([yshift=5mm]EffWeeding1.north west-|AgricManagEff1.north-|FarmConstraints1.north) -- (FarmConstraints1.north);

\end{tikzpicture}
%% End of Farming Constraints BNs %%%%
```

#### Results {#IV233}

The results of the model simulations are presented in Figure \@ref(fig:fig9). Yield function seems to have kept the right-skewed gamma distribution shape, meaning that crop yield in the study area is characterized by relatively higher frequency of low values. In general, chances of yield gain above 100 tons are pretty low or inexistence despite the ranges of uncertainty from this value.

Under drought risk conditions and controlled pest and diseases, rice seems to experience higher yield reduction when weeds are not appropriately managed. With proper weeds removal, it is rather sorghum that seems to be more exposed to yield loss. In both crops, the ranges of yield losses seem to shrink with weed reduction. This means rice is likely to be more sensitive to weeds than sorghum when they are grown under drought and minor pest and diseases. This trend seems to have not much changed with the severity of pest and disease. Nonetheless, sorghum might be generally more exposed to yield loss regardless of the level of weed whereas both crop yield distributions become relatively leptokurtic, owing the narrow range of yield possibility. In general sorghum performed better under drought than rice

```{r case study 3 results rds 1, eval=TRUE, include = FALSE, echo = FALSE, cache = FALSE}
## constructing the evidence list ####
net <- readRDS("output_files/Modelling_FBFS_BNs_Case_study_3.rds")
evidence <- c("Pest_and_desease_impact_at_mid_stage", "Weeds_impact_at_mid_stage", "Crop_type", "Available_soil_water_at_mid_stage")

evidence <- sapply(evidence, function (i){
  out <- dimnames(net[[i]][['prob']])[[1]]
  # Consider the extremes only 
  out[c(1, length(out))]
}, simplify = FALSE)

evidence <- expand.grid(evidence)
evidence <- sapply(evidence, as.character)

make_evidence <- function(evidence_matrix){
  tmp <- 1:nrow(evidence_matrix)
  names(tmp) <- paste0('Traitment_', tmp)
  sapply(tmp, function(i){
    out <- evidence_matrix[i, ]
    names(out) <- colnames(evidence_matrix)
    out
  }, simplify = FALSE)
}

evidence_list <- make_evidence(evidence)
evidence_list_rice <- sapply(evidence_list, function(i) {
  if (i[['Crop_type']] == "Rice"){
    return(TRUE)
  } else {
    return(FALSE)
  }
})
evidence_list_sorghum <- evidence_list[!evidence_list_rice]
evidence_list_rice <- evidence_list[evidence_list_rice]
```

```{r case study 3 results rds 2, eval=TRUE, include = FALSE, echo = FALSE, cache = FALSE}

## Running the MC similation ####
model_function <- function(x){
  # initial stage

  attainable_yield_at_initial_stage <- x[, 2] * x[, 6]

  exploitable_yield_gap_at_initial_stage <- attainable_yield_at_initial_stage - x[, 10] # This holds in normal situation
    exploitable_yield_gap_at_initial_stage <- ifelse(exploitable_yield_gap_at_initial_stage < 0, 0, exploitable_yield_gap_at_initial_stage) # because average yield cannot go beyond attainable.
  bio_exp <- x[, 21] - (x[, 21] * x[, 1]) # Farming Constraints alters the normal situation assuming that crop growth depends on farming constraints
  exploitable_yield_gap_at_initial_stage <-  exploitable_yield_gap_at_initial_stage + (exploitable_yield_gap_at_initial_stage * bio_exp) #

  exploitable_yield_gap_loss_due_to_constraints_at_initial_stage <- exploitable_yield_gap_at_initial_stage - (exploitable_yield_gap_at_initial_stage * x[, 1])
exploitable_yield_gap_loss_due_to_constraints_at_initial_stage <- ifelse(exploitable_yield_gap_loss_due_to_constraints_at_initial_stage <= exploitable_yield_gap_at_initial_stage, exploitable_yield_gap_loss_due_to_constraints_at_initial_stage, exploitable_yield_gap_at_initial_stage) # because exploitable_yield_gap_loss_due_to_constraints_at_initial_stage cannot exceed the exploitable_yield_gap_at_initial_stage itself.

  actually_exploited_yield_gap_at_initial_stage <- exploitable_yield_gap_at_initial_stage - exploitable_yield_gap_loss_due_to_constraints_at_initial_stage
  # expected_actual_yield_at_initial_stage <- actually_exploited_yield_gap_at_initial_stage + x[, 4]
    expected_actual_yield_at_initial_stage <- actually_exploited_yield_gap_at_initial_stage + (attainable_yield_at_initial_stage-exploitable_yield_gap_at_initial_stage) # the second term is the new translation of average yield ([,4]) accounting for farming constraints

  expected_actual_yield_at_initial_stage <- ifelse(expected_actual_yield_at_initial_stage > attainable_yield_at_initial_stage, attainable_yield_at_initial_stage, expected_actual_yield_at_initial_stage) # becuase yield expectation cannot go beyond the attainable limit.

  initial_stage = list(
    exploitable_yield_gap_at_initial_stage = exploitable_yield_gap_at_initial_stage,
    exploitable_yield_gap_loss_due_to_constraints_at_initial_stage = exploitable_yield_gap_loss_due_to_constraints_at_initial_stage,
    actually_exploited_yield_gap_at_initial_stage = actually_exploited_yield_gap_at_initial_stage,
    expected_actual_yield_at_initial_stage=expected_actual_yield_at_initial_stage)

  # dev stage
  bio_exp <- x[,15] - (x[, 15] * x[, 14])

  exploitable_yield_gap_at_development_stage <- exploitable_yield_gap_at_initial_stage + (exploitable_yield_gap_at_initial_stage * bio_exp)

  exploitable_yield_gap_loss_due_to_constraints_at_development_stage <- exploitable_yield_gap_at_development_stage * x[, 14]
  exploitable_yield_gap_loss_due_to_constraints_at_development_stage <- ifelse(exploitable_yield_gap_loss_due_to_constraints_at_development_stage <= exploitable_yield_gap_at_development_stage, exploitable_yield_gap_loss_due_to_constraints_at_development_stage, exploitable_yield_gap_at_development_stage) # because exploitable_yield_gap_loss_due_to_constraints_at_development_stage cannot exceed the exploitable_yield_gap_at_development_stage itself.

  actually_exploited_yield_gap_at_development_stage <- exploitable_yield_gap_at_development_stage - exploitable_yield_gap_loss_due_to_constraints_at_development_stage

  # expected_actual_yield_at_development_stage <- actually_exploited_yield_gap_at_development_stage + (expected_actual_yield_at_initial_stage * x[, 6])
    expected_actual_yield_at_development_stage <- actually_exploited_yield_gap_at_development_stage + (expected_actual_yield_at_initial_stage * bio_exp)


  dev_stage = list(exploitable_yield_gap_at_development_stage = exploitable_yield_gap_at_development_stage,
                   exploitable_yield_gap_loss_due_to_constraints_at_development_stage = exploitable_yield_gap_loss_due_to_constraints_at_development_stage,
                   actually_exploited_yield_gap_at_development_stage = actually_exploited_yield_gap_at_development_stage,
                   expected_actual_yield_at_development_stage = expected_actual_yield_at_development_stage)

  # mid stage
    bio_exp <- x[,17] - (x[, 17] * x[, 16])

  exploitable_yield_gap_at_mid_stage <- exploitable_yield_gap_at_development_stage + (exploitable_yield_gap_at_development_stage * bio_exp)

  exploitable_yield_gap_loss_due_to_constraints_at_mid_stage <- exploitable_yield_gap_at_mid_stage * x[, 16]
  exploitable_yield_gap_loss_due_to_constraints_at_mid_stage <- ifelse(exploitable_yield_gap_loss_due_to_constraints_at_mid_stage <= exploitable_yield_gap_at_mid_stage, exploitable_yield_gap_loss_due_to_constraints_at_mid_stage, exploitable_yield_gap_at_mid_stage) # because exploitable_yield_gap_loss_due_to_constraints_at_mid_stage cannot exceed the exploitable_yield_gap_at_mid_stage itself.

  actually_exploited_yield_gap_at_mid_stage <- exploitable_yield_gap_at_mid_stage - exploitable_yield_gap_loss_due_to_constraints_at_mid_stage

  # expected_actual_yield_at_mid_stage <-  actually_exploited_yield_gap_at_mid_stage + (expected_actual_yield_at_development_stage * x[, 8])
  expected_actual_yield_at_mid_stage <-  actually_exploited_yield_gap_at_mid_stage + (expected_actual_yield_at_development_stage * bio_exp)

  mid_stage = list(exploitable_yield_gap_at_mid_stage = exploitable_yield_gap_at_mid_stage,
                   exploitable_yield_gap_loss_due_to_constraints_at_mid_stage = exploitable_yield_gap_loss_due_to_constraints_at_mid_stage,
                   actually_exploited_yield_gap_at_mid_stage = actually_exploited_yield_gap_at_mid_stage,
                   expected_actual_yield_at_mid_stage = expected_actual_yield_at_mid_stage)

  # late stage
    bio_exp <- x[,19] - (x[, 19] * x[, 18])

  exploitable_yield_gap_at_late_stage <- exploitable_yield_gap_at_mid_stage + (exploitable_yield_gap_at_mid_stage * bio_exp)

  exploitable_yield_gap_loss_due_to_constraints_at_late_stage <- exploitable_yield_gap_at_late_stage * x[, 18]
  exploitable_yield_gap_loss_due_to_constraints_at_late_stage <- ifelse(exploitable_yield_gap_loss_due_to_constraints_at_late_stage <= exploitable_yield_gap_at_late_stage, exploitable_yield_gap_loss_due_to_constraints_at_late_stage, exploitable_yield_gap_at_late_stage) # because exploitable_yield_gap_loss_due_to_constraints_at_late_stage cannot exceed the exploitable_yield_gap_at_late_stage itself.

  actually_exploited_yield_gap_at_late_stage <- exploitable_yield_gap_at_late_stage - exploitable_yield_gap_loss_due_to_constraints_at_late_stage

  expected_actual_yield_at_late_stage <-  actually_exploited_yield_gap_at_late_stage + (expected_actual_yield_at_mid_stage * bio_exp)

  late_stage = list(exploitable_yield_gap_at_late_stage = exploitable_yield_gap_at_late_stage,
                    exploitable_yield_gap_loss_due_to_constraints_at_late_stage = exploitable_yield_gap_loss_due_to_constraints_at_late_stage,
                    actually_exploited_yield_gap_at_late_stage = actually_exploited_yield_gap_at_late_stage,
                    expected_actual_yield_at_late_stage = expected_actual_yield_at_late_stage)

  # grain yield
  actually_exploited_yield_gap = actually_exploited_yield_gap_at_late_stage * x[, 20]
  exploitable_yield_gap = exploitable_yield_gap_at_late_stage * x[, 20]
  expected_actual_yield = expected_actual_yield_at_late_stage * x[, 20]
  exploitable_yield_gap_loss_due_to_constraints = exploitable_yield_gap_loss_due_to_constraints_at_late_stage * x[, 20]

  grain_yield = list(exploitable_yield_gap = exploitable_yield_gap,
                     exploitable_yield_gap_loss_due_to_constraints = exploitable_yield_gap_loss_due_to_constraints,
                     actually_exploited_yield_gap = actually_exploited_yield_gap,
                     expected_actual_yield = expected_actual_yield)


  ## Outputs
  out <- list(initial_stage = initial_stage, dev_stage = dev_stage, mid_stage = mid_stage,
              late_stage = late_stage, grain_yield = grain_yield)

  return(out)
} # Enf of Model Function


### Rice ####
## yield potential estimate #####

# mc_nodes_estimates_biomass_yield_pot <- data.frame(lower = 0.5124928, median = 1.3394095, upper = 4.0000000, distribution = 'gamma', method = 'fit',
#                                                    stringsAsFactors = FALSE, row.names = 'biomass_Yield_Pot_initial_stage')
# mc_nodes_estimates_biomass_yield_pot <- as.estimate(mc_nodes_estimates_biomass_yield_pot)
# 
# ## Average yield estimates ####
# 
# mc_nodes_average_actu_biomass_yield <- data.frame(lower = 0.1824260, median = 0.2543113, upper = 0.3650954, distribution = 'unif', method = 'fit',
#                                                   stringsAsFactors = FALSE, row.names = 'average_Actual_yield_initial_stage')
# mc_nodes_average_actu_biomass_yield <- as.estimate(mc_nodes_average_actu_biomass_yield)

mc_nodes_biomass_exp_factor_init <- list(mc_nodes_lower_biomass_exp_factor_init=estimate(distribution = 'gamma', lower = .Machine$double.eps, median = 0.19-0.1, upper = 0.20-0.1, variable= 'biomass_exp_factor_init', method = 'fit'),
                                         mc_nodes_mid_biomass_exp_factor_init=estimate(distribution = 'gamma', lower = 0.18, median = 0.19, upper = 0.20, variable= 'biomass_exp_factor_init', method = 'fit'),
                                         mc_nodes_upper_biomass_exp_factor_init=estimate(distribution = 'gamma', lower = 0.19, median = 0.19+0.1, upper = 0.20+0.1, variable= 'biomass_exp_factor_init', method = 'fit'))


mc_nodes_biomass_exp_factor_mid <- list(mc_nodes_lower_biomass_exp_factor_dev=estimate(distribution = 'gamma', lower = .Machine$double.eps, median = 0.49-0.1, upper = 0.50-0.1, variable= 'biomass_exp_factor_dev', method = 'fit'),
                                        mc_nodes_mid_biomass_exp_factor_dev=estimate(distribution = 'gamma', lower = 0.20, median = 0.49, upper = 0.50, variable= 'biomass_exp_factor_dev', method = 'fit'),
                                        mc_nodes_upper_biomass_exp_factor_dev=estimate(distribution = 'gamma', lower = 0.40, median = 0.49+0.1, upper = 0.50+0.1, variable= 'biomass_exp_factor_dev', method = 'fit'))

mc_nodes_biomass_exp_factor_dev <- list(mc_nodes_lower_biomass_exp_factor_mid=estimate(distribution = 'gamma', lower = .Machine$double.eps, median = 0.19-0.1, upper = 0.20-0.1, variable= 'biomass_exp_factor_mid', method = 'fit'),
                                        mc_nodes_mid_biomass_exp_factor_mid=estimate(distribution = 'gamma', lower = 0.18, median = 0.19, upper = 0.20, variable= 'biomass_exp_factor_mid', method = 'fit'),
                                        mc_nodes_upper_biomass_exp_factor_mid=estimate(distribution = 'gamma', lower = 0.19, median = 0.19+0.1, upper = 0.20+0.1, variable= 'biomass_exp_factor_mid', method = 'fit'))

mc_nodes_biomass_exp_factor_late <- list(mc_nodes_lower_biomass_exp_factor_late=estimate(distribution = 'gamma', lower = .Machine$double.eps, median = 0.09-0.01, upper = 0.10-0.01, variable= 'biomass_exp_factor_late', method = 'fit'),
                                         mc_nodes_mid_biomass_exp_factor_late=estimate(distribution = 'gamma', lower = 0.05, median = 0.09, upper = 0.10, variable= 'biomass_exp_factor_late', method = 'fit'),
                                         mc_nodes_upper_biomass_exp_factor_late=estimate(distribution = 'gamma', lower = 0.08, median = 0.09+0.01, upper = 0.10+0.01, variable= 'biomass_exp_factor_late', method = 'fit'))

mc_nodes_harvest_index <- list(mc_nodes_lower_harvest_index=estimate(distribution = 'gamma', lower = .Machine$double.eps, median=0.1, upper = 0.3, variable= 'harvest_index', method = 'fit'),
                               mc_nodes_mid_harvest_index=estimate(distribution = 'gamma', lower = 0.2, median=0.4, upper = 0.5, variable= 'harvest_index', method = 'fit'),
                               mc_nodes_upper_harvest_index=estimate(distribution = 'gamma', lower = 0.3, median=0.6, upper = 0.7, variable= 'harvest_index', method = 'fit'))


source("data_files/rice.R")
stage_ratio = c(initial_stage = 0.27,  development_stage = 0.80, mid_stage = 0.95, late_stage = 1)

make_grain_node_states_estimates <- function(network, evidence, node, state_effects = c(0.9, 0.6, 0.1)){
  
  if (inherits(network, 'bn.fit')){
    network <- as.grain(network)
  }
  out <- querygrain(object=network, evidence=evidence, nodes=node)
  name_out <- paste(names(out), "=", unlist(dimnames(out[[1]]), use.names = FALSE), sep = "")
  out <- as.numeric(out[[1]])
  names(out) <- name_out
  tmp <- 1:length(out)
  names(tmp) <- name_out
  out <- mapply("*", out, state_effects)
  out <- sapply(tmp, function(i){
    est_data_frame <- data.frame(distribution = "const", lower = out[[i]], median = out[[i]], upper = out[[i]], method = 'fit', stringsAsFactors = FALSE)
    rownames(est_data_frame) <- name_out[[i]]
    as.estimate(est_data_frame)
  }, simplify = FALSE)
  out
}

## yield potential estimate #####
mc_nodes_estimates_biomass_yield_pot <- guess_decisionSupport_estimates (data = list(potential_grain_yield, 
                                                                                     # harvest_index = harvest_index, 
                                                                                     stage_ratio = stage_ratio), 
                                                                         fun = guess_biomass_yield,
                                                                         distr = rep('gamma', 4), 
                                                                         percentiles = c(0.025, 0.5, 0.975), 
                                                                         plot = FALSE, show.output = FALSE)
rownames(mc_nodes_estimates_biomass_yield_pot$marginal) <- paste0('biomass_Yield_Pot_', rownames(mc_nodes_estimates_biomass_yield_pot$marginal))

## Attainable yield estimates : Median, Lowest and Highest ####

mc_nodes_lower_exploitable_biomass_yield_pot <- data.frame(lower = c(initial_stage = 0.85-0.35, mid_stage = 0.80-0.35, development_stage = 0.75-0.35, late_stage = 0.70-0.35),
                                                           median = c(initial_stage = 0.89-0.35, mid_stage = 0.87-0.35, development_stage = 0.80-0.35, late_stage = 0.71-0.35),
                                                           upper = c(initial_stage = 0.90-0.35, mid_stage = 0.90-0.35, development_stage = 0.90-0.35, late_stage = 0.90-0.35),
                                                           distribution = c(initial_stage = 'unif', mid_stage = 'unif', development_stage = 'unif', late_stage = 'unif'),
                                                           method = c(initial_stage = 'fit', mid_stage = 'fit', development_stage = 'fit', late_stage = 'fit'),
                                                           stringsAsFactors = FALSE)

rownames(mc_nodes_lower_exploitable_biomass_yield_pot) <- paste0('lower_exploitable_biomass_yield_pot_', rownames(mc_nodes_lower_exploitable_biomass_yield_pot))
mc_nodes_lower_exploitable_biomass_yield_pot <- as.estimate(mc_nodes_lower_exploitable_biomass_yield_pot)

mc_nodes_mid_exploitable_biomass_yield_pot <-  data.frame(lower = c(initial_stage = 0.85-0.15, mid_stage = 0.80-0.15, development_stage = 0.75-0.15, late_stage = 0.70-0.15),
                                                          median = c(initial_stage = 0.89-0.15, mid_stage = 0.87-0.15, development_stage = 0.80-0.15, late_stage = 0.71-0.15),
                                                          upper = c(initial_stage = 0.90-0.15, mid_stage = 0.90-0.15, development_stage = 0.90-0.15, late_stage = 0.90-0.15),
                                                          distribution = c(initial_stage = 'unif', mid_stage = 'unif', development_stage = 'unif', late_stage = 'unif'),
                                                          method = c(initial_stage = 'fit', mid_stage = 'fit', development_stage = 'fit', late_stage = 'fit'),
                                                          stringsAsFactors = FALSE)

rownames(mc_nodes_mid_exploitable_biomass_yield_pot) <- paste0('mid_exploitable_biomass_yield_pot_', rownames(mc_nodes_mid_exploitable_biomass_yield_pot))
mc_nodes_mid_exploitable_biomass_yield_pot <- as.estimate(mc_nodes_mid_exploitable_biomass_yield_pot)


mc_nodes_upper_exploitable_biomass_yield_pot <- data.frame(lower = c(initial_stage = 0.85, mid_stage = 0.80, development_stage = 0.75, late_stage = 0.70),
                                                           median = c(initial_stage = 0.89, mid_stage = 0.87, development_stage = 0.80, late_stage = 0.71),
                                                           upper = c(initial_stage = 0.90, mid_stage = 0.90, development_stage = 0.90, late_stage = 0.90),
                                                           distribution = c(initial_stage = 'unif', mid_stage = 'unif', development_stage = 'unif', late_stage = 'unif'),
                                                           method = c(initial_stage = 'fit', mid_stage = 'fit', development_stage = 'fit', late_stage = 'fit'),
                                                           stringsAsFactors = FALSE)
rownames(mc_nodes_upper_exploitable_biomass_yield_pot) <- paste0('upper_exploitable_biomass_yield_pot_', rownames(mc_nodes_upper_exploitable_biomass_yield_pot))
mc_nodes_upper_exploitable_biomass_yield_pot <- as.estimate(mc_nodes_upper_exploitable_biomass_yield_pot)

mc_nodes_exploitable_biomass_yield_pot <- list(mc_nodes_lower_exploitable_biomass_yield_pot, mc_nodes_mid_exploitable_biomass_yield_pot, mc_nodes_upper_exploitable_biomass_yield_pot)

## Average yield estimates: Median, Lowest and Highest ####

cond <- get_boxplot_range_1d (observed_actual_grain_yield)
mc_nodes_lower_average_actu_biomass_yield <- observed_actual_grain_yield[observed_actual_grain_yield >= cond[1] & observed_actual_grain_yield < cond[3]]
mc_nodes_mid_average_actu_biomass_yield <- observed_actual_grain_yield[observed_actual_grain_yield >= cond[3] & observed_actual_grain_yield < cond[5]]
mc_nodes_upper_average_actu_biomass_yield <- observed_actual_grain_yield[observed_actual_grain_yield >= cond[5] & observed_actual_grain_yield < cond[7]]

mc_nodes_lower_average_actu_biomass_yield <- guess_decisionSupport_estimates (data = list(mc_nodes_lower_average_actu_biomass_yield, 
                                                                                          # harvest_index = harvest_index,
                                                                                          stage_ratio = stage_ratio), fun=guess_biomass_yield, distr = rep('gamma', 4),
                                                                              percentiles = c(0.025, 0.5, 0.975), plot = FALSE, show.output = FALSE)
rownames(mc_nodes_lower_average_actu_biomass_yield$marginal) <- paste0('lower_average_Actual_yield_', rownames(mc_nodes_lower_average_actu_biomass_yield$marginal))


mc_nodes_mid_average_actu_biomass_yield <- guess_decisionSupport_estimates (data = list(mc_nodes_mid_average_actu_biomass_yield, 
                                                                                        # harvest_index = harvest_index,
                                                                                        stage_ratio = stage_ratio), fun=guess_biomass_yield, distr = rep('gamma', 4),
                                                                            percentiles = c(0.025, 0.5, 0.975), plot = FALSE, show.output = FALSE)
rownames(mc_nodes_mid_average_actu_biomass_yield$marginal) <- paste0('mid_average_Actual_yield_', rownames(mc_nodes_mid_average_actu_biomass_yield$marginal))


mc_nodes_upper_average_actu_biomass_yield <- guess_decisionSupport_estimates (data = list(mc_nodes_upper_average_actu_biomass_yield, 
                                                                                          # harvest_index = harvest_index,
                                                                                          stage_ratio = stage_ratio), fun=guess_biomass_yield, distr = rep('gamma', 4),
                                                                              percentiles = c(0.025, 0.5, 0.975), plot = FALSE, show.output = FALSE)
rownames(mc_nodes_upper_average_actu_biomass_yield$marginal) <- paste0('upper_average_Actual_yield_', rownames(mc_nodes_upper_average_actu_biomass_yield$marginal))
mc_nodes_average_actu_biomass_yield <- list(mc_nodes_lower_average_actu_biomass_yield, mc_nodes_mid_average_actu_biomass_yield, mc_nodes_upper_average_actu_biomass_yield)

ssp <- sapply(evidence_list_rice, function(evid){
  ## associate average yield and the exploitable yield potential to their corresponding BNs nodes ####
  tmp <- 1:length(Local_constraints_at_initial_stage_estimates)
  names(tmp) <- names(Local_constraints_at_initial_stage_estimates)
  est_int <- sapply(X=tmp, function(i){
    rbind (Local_constraints_at_initial_stage_estimates [[i]],
           mc_nodes_estimates_biomass_yield_pot, 
           mc_nodes_exploitable_biomass_yield_pot[[i]],
           mc_nodes_average_actu_biomass_yield[[i]]
    )
  }, simplify = FALSE, USE.NAMES = TRUE)
  
  ## Biomass yield at dev stage #####
  tmp <- 1:length(Local_constraints_at_development_stage_estimates)
  names(tmp) <- names(Local_constraints_at_development_stage_estimates)
  est_dev <- lapply(X=tmp, FUN = function(i){
        lapply(est_int, function(j){
          rbind(j,
                Local_constraints_at_development_stage_estimates[[i]],
                mc_nodes_biomass_exp_factor_dev[[i]])
        })
  })

  
  ## Biomass yield at mid stage #####
  # Local_constraints_at_mid_stage_estimates <- make_node_states_estimates(bn=net, node='Local_constraints_at_mid_stage', op = 'proba', distr = 'beta', state_effects = c(0.9, 0.6, 0.1), evidence = evid, include_relatives = FALSE)
    Local_constraints_at_mid_stage_estimates <- make_grain_node_states_estimates(network = net, node='Local_constraints_at_mid_stage', evidence = evid, state_effects = c(0.9, 0.6, 0.1))
  
  tmp <- 1:length(Local_constraints_at_mid_stage_estimates)
  names(tmp) <- names(Local_constraints_at_mid_stage_estimates)
  est_mid <- lapply(X=tmp, FUN = function(i){
    lapply(est_dev, function(j) {
      lapply(j, function (k){
        rbind(k,
              Local_constraints_at_mid_stage_estimates[[i]],
              mc_nodes_biomass_exp_factor_mid[[i]])
      })
    })
  })
  
  ## Biomass yield at late stage #####
  # Local_constraints_at_late_stage_estimates <- make_node_states_estimates(bn=net, node='Local_constraints_at_late_stage', op = 'proba', distr = 'beta', state_effects = c(0.9, 0.6, 0.1), evidence = evid, include_relatives = FALSE)
    Local_constraints_at_late_stage_estimates <- make_grain_node_states_estimates(network = net, node = 'Local_constraints_at_late_stage', evidence = evid, state_effects = c(0.9, 0.6, 0.1))

  
  tmp <- 1:length(Local_constraints_at_late_stage_estimates)
  names(tmp) <- names(Local_constraints_at_late_stage_estimates)
  est_late <- lapply(X=tmp, FUN = function(i){
    lapply(est_mid, function(j) {
      lapply(j, function(k){
        lapply(k, function (l){
          rbind(l,
                Local_constraints_at_late_stage_estimates[[i]],
                mc_nodes_biomass_exp_factor_late[[i]], 
                mc_nodes_harvest_index[[i]],
                mc_nodes_biomass_exp_factor_init[[i]])
        })
      })
    })
  })
  
  state_ids = 1:length(est_late)
  names(state_ids) <- names(est_late)
  
  sapply(X=state_ids, function (i) {
    sapply(est_late[[i]], function (j){
      sapply(j, function(k){
        sapply(k, function(l){
          mcSimulation(estimate = l, model_function = model_function, numberOfModelRuns=1000, functionSyntax="matrixNames")
        }, simplify = FALSE, USE.NAMES = TRUE)
      }, simplify = FALSE, USE.NAMES = TRUE)
    }, simplify = FALSE, USE.NAMES = TRUE)
  }, simplify = FALSE, USE.NAMES = TRUE)
}, simplify = FALSE, USE.NAMES = TRUE)

saveRDS(ssp, paste0("output_files", "/", "Modelling_FBFS_model_RICE_RAW_predictions_Case_study_3.rds"))
rm(ssp); gc(verbose=FALSE)
#### Sorghum #####

## yield potential estimate #####

# mc_nodes_estimates_biomass_yield_pot <- data.frame(lower = 0.1066141, median = 0.91816159, upper = 4.0754789, distribution = 'gamma', method = 'fit',
#                                                    stringsAsFactors = FALSE, row.names = 'biomass_Yield_Pot_initial_stage')
# mc_nodes_estimates_biomass_yield_pot <- as.estimate(mc_nodes_estimates_biomass_yield_pot)
# 
# ## Average yield estimates ####
# 
# mc_nodes_average_actu_biomass_yield <- data.frame(lower = 0.1824260, median = 0.2543113+0.09, upper = 0.3650954, distribution = 'unif', method = 'fit',
#                                                   stringsAsFactors = FALSE, row.names = 'average_Actual_yield_initial_stage')
# mc_nodes_average_actu_biomass_yield <- as.estimate(mc_nodes_average_actu_biomass_yield)

source("data_files/sorghum.R")
## yield potential estimate #####
mc_nodes_estimates_biomass_yield_pot <- guess_decisionSupport_estimates (data = list(potential_grain_yield, 
                                                                                     # harvest_index = harvest_index, 
                                                                                     stage_ratio = stage_ratio), 
                                                                         fun = guess_biomass_yield,
                                                                         distr = rep('gamma', 4), 
                                                                         percentiles = c(0.025, 0.5, 0.975), 
                                                                         plot = FALSE, show.output = FALSE)
rownames(mc_nodes_estimates_biomass_yield_pot$marginal) <- paste0('biomass_Yield_Pot_', rownames(mc_nodes_estimates_biomass_yield_pot$marginal))

## Attainable yield estimates : Median, Lowest and Highest ####

mc_nodes_lower_exploitable_biomass_yield_pot <- data.frame(lower = c(initial_stage = 0.85-0.35, mid_stage = 0.80-0.35, development_stage = 0.75-0.35, late_stage = 0.70-0.35),
                                                           median = c(initial_stage = 0.89-0.35, mid_stage = 0.87-0.35, development_stage = 0.80-0.35, late_stage = 0.71-0.35),
                                                           upper = c(initial_stage = 0.90-0.35, mid_stage = 0.90-0.35, development_stage = 0.90-0.35, late_stage = 0.90-0.35),
                                                           distribution = c(initial_stage = 'unif', mid_stage = 'unif', development_stage = 'unif', late_stage = 'unif'),
                                                           method = c(initial_stage = 'fit', mid_stage = 'fit', development_stage = 'fit', late_stage = 'fit'),
                                                           stringsAsFactors = FALSE)

rownames(mc_nodes_lower_exploitable_biomass_yield_pot) <- paste0('lower_exploitable_biomass_yield_pot_', rownames(mc_nodes_lower_exploitable_biomass_yield_pot))
mc_nodes_lower_exploitable_biomass_yield_pot <- as.estimate(mc_nodes_lower_exploitable_biomass_yield_pot)

mc_nodes_mid_exploitable_biomass_yield_pot <-  data.frame(lower = c(initial_stage = 0.85-0.15, mid_stage = 0.80-0.15, development_stage = 0.75-0.15, late_stage = 0.70-0.15),
                                                          median = c(initial_stage = 0.89-0.15, mid_stage = 0.87-0.15, development_stage = 0.80-0.15, late_stage = 0.71-0.15),
                                                          upper = c(initial_stage = 0.90-0.15, mid_stage = 0.90-0.15, development_stage = 0.90-0.15, late_stage = 0.90-0.15),
                                                          distribution = c(initial_stage = 'unif', mid_stage = 'unif', development_stage = 'unif', late_stage = 'unif'),
                                                          method = c(initial_stage = 'fit', mid_stage = 'fit', development_stage = 'fit', late_stage = 'fit'),
                                                          stringsAsFactors = FALSE)

rownames(mc_nodes_mid_exploitable_biomass_yield_pot) <- paste0('mid_exploitable_biomass_yield_pot_', rownames(mc_nodes_mid_exploitable_biomass_yield_pot))
mc_nodes_mid_exploitable_biomass_yield_pot <- as.estimate(mc_nodes_mid_exploitable_biomass_yield_pot)


mc_nodes_upper_exploitable_biomass_yield_pot <- data.frame(lower = c(initial_stage = 0.85, mid_stage = 0.80, development_stage = 0.75, late_stage = 0.70),
                                                           median = c(initial_stage = 0.89, mid_stage = 0.87, development_stage = 0.80, late_stage = 0.71),
                                                           upper = c(initial_stage = 0.90, mid_stage = 0.90, development_stage = 0.90, late_stage = 0.90),
                                                           distribution = c(initial_stage = 'unif', mid_stage = 'unif', development_stage = 'unif', late_stage = 'unif'),
                                                           method = c(initial_stage = 'fit', mid_stage = 'fit', development_stage = 'fit', late_stage = 'fit'),
                                                           stringsAsFactors = FALSE)
rownames(mc_nodes_upper_exploitable_biomass_yield_pot) <- paste0('upper_exploitable_biomass_yield_pot_', rownames(mc_nodes_upper_exploitable_biomass_yield_pot))
mc_nodes_upper_exploitable_biomass_yield_pot <- as.estimate(mc_nodes_upper_exploitable_biomass_yield_pot)

mc_nodes_exploitable_biomass_yield_pot <- list(mc_nodes_lower_exploitable_biomass_yield_pot, mc_nodes_mid_exploitable_biomass_yield_pot, mc_nodes_upper_exploitable_biomass_yield_pot)

## Average yield estimates: Median, Lowest and Highest ####

cond <- get_boxplot_range_1d (observed_actual_grain_yield)
mc_nodes_lower_average_actu_biomass_yield <- observed_actual_grain_yield[observed_actual_grain_yield >= cond[1] & observed_actual_grain_yield < cond[3]]
mc_nodes_mid_average_actu_biomass_yield <- observed_actual_grain_yield[observed_actual_grain_yield >= cond[3] & observed_actual_grain_yield < cond[5]]
mc_nodes_upper_average_actu_biomass_yield <- observed_actual_grain_yield[observed_actual_grain_yield >= cond[5] & observed_actual_grain_yield < cond[7]]

mc_nodes_lower_average_actu_biomass_yield <- guess_decisionSupport_estimates (data = list(mc_nodes_lower_average_actu_biomass_yield, 
                                                                                          # harvest_index = harvest_index,
                                                                                          stage_ratio = stage_ratio), fun=guess_biomass_yield, distr = rep('gamma', 4),
                                                                              percentiles = c(0.025, 0.5, 0.975), plot = FALSE, show.output = FALSE)
rownames(mc_nodes_lower_average_actu_biomass_yield$marginal) <- paste0('lower_average_Actual_yield_', rownames(mc_nodes_lower_average_actu_biomass_yield$marginal))


mc_nodes_mid_average_actu_biomass_yield <- guess_decisionSupport_estimates (data = list(mc_nodes_mid_average_actu_biomass_yield, 
                                                                                        # harvest_index = harvest_index,
                                                                                        stage_ratio = stage_ratio), fun=guess_biomass_yield, distr = rep('gamma', 4),
                                                                            percentiles = c(0.025, 0.5, 0.975), plot = FALSE, show.output = FALSE)
rownames(mc_nodes_mid_average_actu_biomass_yield$marginal) <- paste0('mid_average_Actual_yield_', rownames(mc_nodes_mid_average_actu_biomass_yield$marginal))


mc_nodes_upper_average_actu_biomass_yield <- guess_decisionSupport_estimates (data = list(mc_nodes_upper_average_actu_biomass_yield, 
                                                                                          # harvest_index = harvest_index,
                                                                                          stage_ratio = stage_ratio), fun=guess_biomass_yield, distr = rep('gamma', 4),
                                                                              percentiles = c(0.025, 0.5, 0.975), plot = FALSE, show.output = FALSE)
rownames(mc_nodes_upper_average_actu_biomass_yield$marginal) <- paste0('upper_average_Actual_yield_', rownames(mc_nodes_upper_average_actu_biomass_yield$marginal))
mc_nodes_average_actu_biomass_yield <- list(mc_nodes_lower_average_actu_biomass_yield, mc_nodes_mid_average_actu_biomass_yield, mc_nodes_upper_average_actu_biomass_yield)

ssp <- sapply(evidence_list_sorghum, function(evid){
  ## associate average yield and the exploitable yield potential to their corresponding BNs nodes ####
  tmp <- 1:length(Local_constraints_at_initial_stage_estimates)
  names(tmp) <- names(Local_constraints_at_initial_stage_estimates)
  est_int <- sapply(X=tmp, function(i){
    rbind (Local_constraints_at_initial_stage_estimates [[i]],
           mc_nodes_estimates_biomass_yield_pot, 
           mc_nodes_exploitable_biomass_yield_pot[[i]],
           mc_nodes_average_actu_biomass_yield[[i]]
    )
  }, simplify = FALSE, USE.NAMES = TRUE)
  
  ## Biomass yield at dev stage #####
  tmp <- 1:length(Local_constraints_at_development_stage_estimates)
  names(tmp) <- names(Local_constraints_at_development_stage_estimates)
  est_dev <- lapply(X=tmp, FUN = function(i){
        lapply(est_int, function(j){
          rbind(j,
                Local_constraints_at_development_stage_estimates[[i]],
                mc_nodes_biomass_exp_factor_dev[[i]])
        })
  })

  
  ## Biomass yield at mid stage #####
  # Local_constraints_at_mid_stage_estimates <- make_node_states_estimates(bn=net, node='Local_constraints_at_mid_stage', op = 'proba', distr = 'beta', state_effects = c(0.9, 0.6, 0.1), evidence = evid, include_relatives = FALSE)
  Local_constraints_at_mid_stage_estimates <- make_grain_node_states_estimates(network = net, node='Local_constraints_at_mid_stage', evidence = evid, state_effects = c(0.9, 0.6, 0.1))

  tmp <- 1:length(Local_constraints_at_mid_stage_estimates)
  names(tmp) <- names(Local_constraints_at_mid_stage_estimates)
  est_mid <- lapply(X=tmp, FUN = function(i){
    lapply(est_dev, function(j) {
      lapply(j, function (k){
        rbind(k,
              Local_constraints_at_mid_stage_estimates[[i]],
              mc_nodes_biomass_exp_factor_mid[[i]])
      })
    })
  })
  
  ## Biomass yield at late stage #####
  # Local_constraints_at_late_stage_estimates <- make_node_states_estimates(bn=net, node='Local_constraints_at_late_stage', op = 'proba', distr = 'beta', state_effects = c(0.9, 0.6, 0.1), evidence = evid, include_relatives = FALSE)
      Local_constraints_at_late_stage_estimates <- make_grain_node_states_estimates(network = net, node = 'Local_constraints_at_late_stage', evidence = evid, state_effects = c(0.9, 0.6, 0.1))

  
  tmp <- 1:length(Local_constraints_at_late_stage_estimates)
  names(tmp) <- names(Local_constraints_at_late_stage_estimates)
  est_late <- lapply(X=tmp, FUN = function(i){
    lapply(est_mid, function(j) {
      lapply(j, function(k){
        lapply(k, function (l){
          rbind(l,
                Local_constraints_at_late_stage_estimates[[i]],
                mc_nodes_biomass_exp_factor_late[[i]], 
                mc_nodes_harvest_index[[i]],
                mc_nodes_biomass_exp_factor_init[[i]])
        })
      })
    })
  })
  
  state_ids = 1:length(est_late)
  names(state_ids) <- names(est_late)
  
  sapply(X=state_ids, function (i) {
    sapply(est_late[[i]], function (j){
      sapply(j, function(k){
        sapply(k, function(l){
          mcSimulation(estimate = l, model_function = model_function, numberOfModelRuns=1000, functionSyntax="matrixNames")
        }, simplify = FALSE, USE.NAMES = TRUE)
      }, simplify = FALSE, USE.NAMES = TRUE)
    }, simplify = FALSE, USE.NAMES = TRUE)
  }, simplify = FALSE, USE.NAMES = TRUE)
}, simplify = FALSE, USE.NAMES = TRUE)
saveRDS(ssp, paste0("output_files", "/", "Modelling_FBFS_model_SORGHUM_RAW_predictions_Case_study_3.rds"))
rm(ssp); gc(verbose=FALSE)
```

```{r case study 3 results rds 3, eval=TRUE,include = FALSE, echo = FALSE, cache = FALSE}
## removing objects that are no longer needed ####
rm(list=setdiff(ls(), c("evidence", "my_theme", "plot_font_size"))); gc ()

## some common plots specifications
legend_bg <- adjustcolor( "yellow", alpha.f = 0.15)
plots_lwd <- 0.5
min_plots_width_in <- 2.63
max_plots_width_in <- 7.5
max_plots_height_in <- 8.75
min_plots_res <- 300
plots_compression <- "lzw"
plots_font_family <- 'serif' # 'sans'
plots_font <- 1 # 2
plot_font_size <- 10

ssp1 <- readRDS("output_files/Modelling_FBFS_model_RICE_RAW_predictions_Case_study_3.rds")
ssp2 <- readRDS("output_files/Modelling_FBFS_model_SORGHUM_RAW_predictions_Case_study_3.rds")
ssp <- c(ssp1, ssp2)
rm (ssp1, ssp2); gc(verbose=FALSE)

get_dens_mcsimilation_data <- function(x,
                                       colorQuantile = c("GRAY48", "YELLOW", "ORANGE", "DARK GREEN", "ORANGE1", "YELLOW1", "GRAY49"),
                                       colorProbability = c(1, 0.95, 0.75, 0.55, 0.45, 0.25, 0.05)) {
  
  f <- function(x, colorQuantile, colorProbability) {
    if (length(colorQuantile) != length(colorProbability)){
      stop("colorQuantile should have the same length as colorProbability")
    }
    ids <- match(colorProbability, sort(colorProbability))
    colorProbability <- colorProbability[ids]
    colorQuantile <- colorQuantile[ids]
    dt <- as.data.frame(x$y)
    sapply(dt, function(i) {
      # dens <- density(i)
      dens <- ggplot(data.frame(x=i), aes(x, y=..scaled..))+ geom_density()
      df <- ggplot_build(dens)$data[[1]][2:1]
      # df <- data.frame(x = dens$x, y = dens$y)
      quantiles <- quantile(i, prob = colorProbability)
      df$quant <- factor(findInterval(df$x, quantiles[-length(quantiles)]))
      df$quant_x_breaks <- rep(NA, nrow(df))
      df$color_equiv <- rep(NA, nrow(df))
      df$color <- rep(NA, nrow(df))
      for (i in unique(df$quant)) {
        df[df$quant == i, "quant_x_breaks"] <- max(df[df$quant == i, "x"], na.rm = TRUE)
      }
      for (i in 1:length(unique(df$quant_x_breaks))) {
        df[df$quant_x_breaks == unique(df$quant_x_breaks)[i], "color_equiv"] <- colorProbability[i]
      }
      for (i in 1:length(unique(df$quant_x_breaks))) {
        df[df$quant_x_breaks == unique(df$quant_x_breaks)[i], "color"] <- colorQuantile[i]
      }
      df$quant <- paste0(df$color_equiv * 100, "%")
      return(df)
    }, simplify = FALSE, USE.NAMES = TRUE)
  }
  if ((inherits(x, "mcSimulation", which = TRUE) == 1)) {
    out <- f(x, colorQuantile, colorProbability)
  } else if ((inherits(x, "list", which = TRUE) == 1)) {
    out <- sapply(X = x, FUN = get_dens_mcsimilation_data, colorQuantile = colorQuantile, colorProbability = colorProbability,
                  simplify = FALSE, USE.NAMES = TRUE)
  } else {
    stop(paste(deparse(substitute(x)), "must be of class mcSimulation, list of mcSimulation, or a list of arbitratry depth of mcSimulation objects."))
  }
}
ggplot_mc_dens <- function(x, ...) {
  UseMethod("ggplot_mc_dens", x)
}
ggplot_mc_dens.mcSimulation <- function(x, ...) {
  if (requireNamespace("ggplot2", quietly = TRUE)) {
    bars <- get_dens_mcsimilation_data(x, ...)
    # bars <- sapply (bars, function(i) i$result, simplify = FALSE)
    id.var <- c("x", "y", "color", "color_equiv", "quant")
    result <- reshape2::melt(bars, id.var = id.var)
    ggplot(data = result[order(result$L1, decreasing = T), ], aes_string("x", "y", fill = "color")) +
      geom_density(stat = "identity") + scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0,
                                                                                                             0)) + scale_fill_identity(NULL, labels = result$color_equiv, breaks = result$color, guide = "legend",
                                                                                                                                       drop = FALSE)
  } else {
    stop("ggplot2 is required for the ggplot_mc_hist method.")
  }
}
ggplot_mc_dens.list <- ggplot_mc_dens.mcSimulation
p1 = ggplot_mc_dens(ssp, 
                    colorQuantile = c("red", "green", "green", "green", "green", "green", "red1"),
                    
                    # colorQuantile = c("GRAY46", "lavender", "lavender", "lavender", "lavender", "lavender", "GRAY47"),
                    colorProbability = c(1.00,    0.95,  0.75,     0.55,         0.45,     0.25,     0.05))
rm(ssp); gc(verbose = FALSE)
ssp <- p1$data

ssp <- ssp[ssp$L6=="grain_yield.expected_actual_yield", ]

evidence <- data.frame(evidence, L1=paste0('Traitment_', 1:nrow(evidence)))

ssp <- merge(ssp, evidence, by = "L1", all.x=TRUE, all.y=TRUE)

ssp$Crop_type <- as.character(ssp$Crop_type)

ssp <- ssp[(ssp$L6 == "grain_yield.expected_actual_yield")&
             (ssp$L5 != "Local_constraints_at_initial_stage=Medium")&
             (ssp$L4 != "Local_constraints_at_development_stage=Medium")&
             (ssp$L3 != "Local_constraints_at_mid_stage=Medium")&
             (ssp$L2 != "Local_constraints_at_late_stage=Medium"), ]

ssp$L5 <- gsub("Local_constraints_at_initial_stage=High", "{bold('FC'[italic(i)]==High)}", ssp$L5)
ssp$L5 <- gsub("Local_constraints_at_initial_stage=Low", "{bold('FC'[italic(i)]==Low)}", ssp$L5)

ssp$L5 <- gsub(pattern = 'Low', replacement = "L", ssp$L5)
ssp$L5 <- gsub(pattern = 'Medium', replacement = "M", ssp$L5)
ssp$L5 <- gsub(pattern = 'High', replacement = "H", ssp$L5)

ssp$L4 <- gsub("Local_constraints_at_development_stage=High", "{bold('FC'[italic(ii)]==High)}", ssp$L4)
ssp$L4 <- gsub("Local_constraints_at_development_stage=Low", "{bold('FC'[italic(ii)]==Low)}", ssp$L4)

ssp$L4 <- gsub(pattern = 'Low', replacement = "L", ssp$L4)
ssp$L4 <- gsub(pattern = 'Medium', replacement = "M", ssp$L4)
ssp$L4 <- gsub(pattern = 'High', replacement = "H", ssp$L4)

ssp$L3 <- gsub("Local_constraints_at_mid_stage=High", "{bold('FC'[italic(iii)]==High)}", ssp$L3)
ssp$L3 <- gsub("Local_constraints_at_mid_stage=Low", "{bold('FC'[italic(iii)]==Low)}", ssp$L3)

ssp$L3 <- gsub(pattern = 'Low', replacement = "L", ssp$L3)
ssp$L3 <- gsub(pattern = 'Medium', replacement = "M", ssp$L3)
ssp$L3 <- gsub(pattern = 'High', replacement = "H", ssp$L3)

ssp$L2 <- gsub("Local_constraints_at_late_stage=High", "{bold('FC'[italic(iiii)]==High)}", ssp$L2)
ssp$L2 <- gsub("Local_constraints_at_late_stage=Low", "{bold('FC'[italic(iiii)]==Low)}", ssp$L2)

ssp$L2 <- gsub(pattern = 'Low', replacement = "L", ssp$L2)
ssp$L2 <- gsub(pattern = 'Medium', replacement = "M", ssp$L2)
ssp$L2 <- gsub(pattern = 'High', replacement = "H", ssp$L2)

ssp$Pest_and_desease_impact_at_mid_stage <- factor(ssp$Pest_and_desease_impact_at_mid_stage, levels = unique(ssp$Pest_and_desease_impact_at_mid_stage))
ssp$Weeds_impact_at_mid_stage <- factor(ssp$Weeds_impact_at_mid_stage, levels = unique(ssp$Weeds_impact_at_mid_stage))
ssp$Available_soil_water_at_mid_stage <- factor(ssp$Available_soil_water_at_mid_stage, levels = unique(ssp$Available_soil_water_at_mid_stage))

ssp$L2 <- factor(ssp$L2, levels = unique(ssp$L2))
ssp$L3 <- factor(ssp$L3, levels = unique(ssp$L3))
ssp$L4 <- factor(ssp$L4, levels = unique(ssp$L4))
ssp$L5 <- factor(ssp$L5, levels = unique(ssp$L5))

labellers <- labeller(
  Pest_and_desease_impact_at_mid_stage = c(Minor = "Pest and desease impact = Minor",
                                           Severe = "Pest and desease impact = Severe"),
  Weeds_impact_at_mid_stage = c(Negligible = "Weeds impact = Negligible",
                                Significant = "Weeds impact = Significant"),
  Available_soil_water_at_mid_stage = c(`Drought risk` = "D",
                                        `Waterlogging risk` = "W"),
  L5 = label_parsed,
  L4 = label_parsed,
  L3 = label_parsed,
  L2 = label_parsed
)
```

```{r case study 3 results plot, eval=TRUE,include = FALSE, echo = FALSE, cache = FALSE}
# p1 <- ggplot (data = ssp, aes(x, fill = interaction(color, Crop_type), color = interaction(color, Crop_type)))+
p1 <- ggplot (data = ssp[ssp$color=='green', ], aes(x, fill = Crop_type, color = Crop_type))+
  # geom_density_ridges(scale=1, size=0.05)+
  geom_density(aes(y=y), stat = 'identity', alpha=0.1)+
  # geom_boxplot(aes(x=Crop_type, y=value))+
  ggnomics::facet_nested(L2+L4+L5 ~ Pest_and_desease_impact_at_mid_stage+Weeds_impact_at_mid_stage+Available_soil_water_at_mid_stage, 
                         space = 'free_x', scales = 'free_x', labeller = labellers)+
  scale_x_continuous(expand = c(0, 0),
                     limits = function(x) c(min(x, na.rm = TRUE), 15),
                     breaks = seq(5, 15, by = 5)
  )+
  scale_y_continuous(expand = c(0,0),
                     breaks = seq(0.25, 0.8, by=0.25),
                     labels = function(x) sprintf("%.1f", x))+
  labs(x = "Grain yield", y = "Density")+
  my_theme+
  theme(
    axis.title = element_blank(),
    legend.position=c(1,1),
    legend.justification = c("right", "top"),
    legend.text = element_text(size = plot_font_size+2, margin = margin(0,0,0,-4)),
    legend.margin=margin(0,0,0,0),
    legend.box = "vertical",
    legend.box.margin=margin(-40,-53,0, 0),
    legend.key.width = unit(0.25/1.5, "cm"),
    legend.key.height = unit(0.05, "cm"),
    strip.text = element_text(size = plot_font_size, face = 'bold'),
    strip.text.x = element_text(margin = margin(t=3, b = 3)),
    axis.text = element_text(size = plot_font_size+2),
    axis.text.x = element_text(hjust = 0.5),
    axis.text.y = element_text(hjust = 0.5),
    axis.ticks.length = unit(0.25, "mm"),
    plot.margin=unit(c(4, 1, 1, 1), "pt")
  )


annotation_custom2 <- function (grob, xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf, data)
{
  layer(data = data, stat = StatIdentity, position = PositionIdentity,
        geom = ggplot2:::GeomCustomAnn,
        inherit.aes = TRUE, params = list(grob = grob,
                                          xmin = xmin, xmax = xmax,
                                          ymin = ymin, ymax = ymax))
}

insets <- plyr::dlply(
  ssp, 
  c('Pest_and_desease_impact_at_mid_stage','Weeds_impact_at_mid_stage','Available_soil_water_at_mid_stage','L5', 'L4', 'L2'), 
  function(d){
    annotation_custom2(
      grob = ggplotGrob(ggplot(data.frame(x=d$Crop_type, y=d$x))+
                          geom_boxplot(aes(x=x, y=y, fill=x, color=x), alpha=0.3, lwd=0.005, outlier.size = 0.05)+
                          my_theme+
                          theme(
                            # plot.background=element_rect(fill='lightgoldenrodyellow', color = "gray"),
                            # plot.background=element_rect(fill=alpha('white', 0.4), color = "white"),
                            plot.background=element_rect(fill='white', color = "white"),
                            panel.border = element_rect(size = 0.025),
                            legend.position = 'none',
                            axis.text.x = element_text(size=plot_font_size+1, margin = margin(c(0.5,0,0,0), unit = 'mm')),
                            axis.ticks.length.x = unit(-0.5, "mm"),
                            # axis.ticks.margin=unit(0.5, "cm"),
                            axis.text.y = element_blank(),
                            axis.ticks.y = element_blank(),
                            axis.ticks.length.y = unit(0, "mm"),
                            axis.title = element_blank())+
                          coord_flip()+
                          scale_y_continuous(expand=c(0,0), limits = function(x) c(min(x, na.rm = TRUE), 20),
                                             breaks = seq(5, 20, by = 10))+
                          scale_x_discrete(expand = c(0,0))),
      data = data.frame(Crop_type=min(d$Crop_type), x=min(d$x), color=1,
                        Pest_and_desease_impact_at_mid_stage=unique(d$Pest_and_desease_impact_at_mid_stage),
                        Weeds_impact_at_mid_stage=unique(d$Weeds_impact_at_mid_stage),
                        Available_soil_water_at_mid_stage=unique(d$Available_soil_water_at_mid_stage),
                        L5=unique(d$L5),
                        L4=unique(d$L4),
                        L3=unique(d$L3),
                        L2=unique(d$L2)), 
      xmin=5.5, 
      xmax=14.5, 
      ymin=0.2, 
      ymax=0.95)
  }
)
rm(ssp); gc(verbose=FALSE)
```

```{r fig11,echo=FALSE, cache.lazy = FALSE, warning=FALSE,message=FALSE,fig.width=max_plots_width_in,fig.height=max_plots_height_in/1.5,dpi=min_plots_res,fig.cap="Effect of Pest and diseases, weeds, and soil water on grain yield of rice and sorghum under FBFS in Kisumu (Kenya) and Tigray (Ethiopia)."}

p1 <- p1+insets

p1 <- list(p1)
p1$ncol=1
p1$top = grid::textGrob("The x-axis of the sub and main plots, respectively, are the the ranges of simulated grain yield in tons/ha and the 90% confidence.
The y-axis of the main plots are the scaled density. FC = farming constraint, H = High, M = Medium, L = Low, D = Drought risk,
W = Waterlogging risk. The indices i, ii, iiii, respectively, indicate crop at initial, developement and late stages.",
                        x=0, hjust=0, vjust = 0.5,
                        gp = gpar(fontfamily=plots_font_family,fontsize=plot_font_size,fontface="italic", col="black"))
grid.newpage()
ga = do.call("grid.arrange", p1)
gb = grid.rect(.5,.5,width=unit(1,"npc"), height=unit(1,"npc"), 
               gp=gpar(lwd=1, fill=NA, col="lightgray"))
g <- gTree(children = gList(ga, gb))
grid.draw(g)

ggsave(plot=g, device='png', filename = "figures/Modelling_FBFS_grain_yield.png", width = max_plots_width_in, 
       height=max_plots_height_in/1.5, units="in", dpi=min_plots_res
)
```

Under waterlogging coupled with minor pest and disease, sorghum exhibits high chance of loss regardless of the level of weeds as it does under drought exacerbated by severe pest and disease. Increasing the effect of pest and diseases along with the level of weeds seems to result in sorghum keeping the higher loss. However, the tendency seems to reverse with proper weed removal in which case rice seems to lose more than does sorghum.

Under drought, minimal pest and disease and high weeds levels, sorghum seems to rather dominate rice in term of yield gain. The situation is unclear when the effect of weeds is removed since sorghum dominate rice up to certain values (nearly 50 tons) wherefrom rice seems to take over. This superiority of sorghum for relatively lower yield gains seems to hold even with the severity of pest and diseases under which condition the possibilities of yield gain are slightly narrower. This confirm rice is more sensitive to weeds than sorghum in the study areas. Note that the performance of rice over sorghum seems to substantially increase with the severity of pest and disease. This means sorghum is likely to be more sensitive to pest and diseases than rice.
Under waterlogging, rice seems to generally dominate sorghum in terms of yield gains regardless of the other factors. Where sorghum seems to do better are generally related to extremely high yield gains which may are necessarily within farmers’ reach.

# Discussion {#V}

For example, crop yield in certain crops such as maize are very sensitive to water stress during flowering and cob formation than during other development stages (Pault, 2013). 

The post hoc test revealed that clay soils are better for soil water contrary to sandy ones. Even without manure addition and little amount of flood, drought is unlikely to occur under clayey soils.  A similar situation is observed under sandy soils when it comes to waterlogging. While drought is not expected under both clayey and sandy soils supplemented with manure and flood, the risk of waterlogging is eminent particularly under clayey soils. In general, normal conditions are rather rare, expect in the sandy soils which have low chance for waterlogging. In general, drought, contrary to waterlogging, is equally unlikely under both loamy and clayey regardless of the manure application if at least the desired amount of flood is expected.

Rice and sorghum yield in the study area are characterized by high frequency of low values and low frequency of high values which exhibit higher uncertainties. Rice seems to be more sensitive to weeds and drought than sorghum which seems to be more affected by pest and diseases. The range of yield possibility seems to narrow with the severity of pest and disease.

# reference {#VI}